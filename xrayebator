#!/bin/bash

# ═══════════════════════════════════════════════════════════
# XRAYEBATOR v1.3.2 EXP - Xray Reality VPN Manager
# GitHub: https://github.com/howdeploy/Xrayebator
# License: MIT
# Экспериментальная версия с исправлениями маршрутизации
# ═══════════════════════════════════════════════════════════

# Цвета
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
MAGENTA='\033[0;35m'
NC='\033[0m'

# Пути
CONFIG_FILE="/usr/local/etc/xray/config.json"
PROFILES_DIR="/usr/local/etc/xray/profiles"
DATA_DIR="/usr/local/etc/xray/data"
PRIVATE_KEY_FILE="/usr/local/etc/xray/.private_key"
PUBLIC_KEY_FILE="/usr/local/etc/xray/.public_key"
SNI_LIST="$DATA_DIR/sni_list.txt"
ASCII_ART="$DATA_DIR/ascii_art.txt"

# Проверка прав root
if [[ $EUID -ne 0 ]]; then
  echo -e "${RED}✗ Требуются права root${NC}"
  echo -e "${YELLOW}Используйте: sudo xrayebator${NC}"
  exit 1
fi

# Загрузка ключей
if [[ -f "$PRIVATE_KEY_FILE" ]] && [[ -f "$PUBLIC_KEY_FILE" ]]; then
  PRIVATE_KEY=$(cat "$PRIVATE_KEY_FILE")
  PUBLIC_KEY=$(cat "$PUBLIC_KEY_FILE")
  if [[ -z "$PRIVATE_KEY" ]] || [[ -z "$PUBLIC_KEY" ]]; then
    echo -e "${RED}✗ Ключи Reality пусты.${NC}"
    echo -e "${YELLOW}Пересоздайте ключи командой:${NC}"
    echo "  cd /usr/local/etc/xray/ && sudo /usr/local/bin/xray x25519 2>&1"
    exit 1
  fi
else
  echo -e "${RED}✗ Ключи Reality не найдены. Запустите install.sh${NC}"
  exit 1
fi

# Получение внешнего IP
get_server_ip() {
  local ip=$(curl -s4 ifconfig.me 2>/dev/null || curl -s4 icanhazip.com 2>/dev/null)
  if [[ -z "$ip" ]]; then
    ip=$(hostname -I | awk '{print $1}')
  fi
  echo "$ip"
}

# ═══════════════════════════════════════════════════════════
# HELPER FUNCTIONS
# ═══════════════════════════════════════════════════════════

# Update SNI for all transport types (transport-aware)
# Args: $1=port, $2=new_sni, $3=config_file
update_transport_settings_for_sni() {
  local port=$1
  local new_sni=$2
  local config_file=$3

  # Convert port to number for jq
  local port_num=$((port))

  # Detect transport type
  local transport=$(jq -r --argjson port "$port_num" \
    '.inbounds[] | select(.port == $port) | .streamSettings.network' \
    "$config_file")

  echo -e "${CYAN}  → Обновление SNI на порту $port (транспорт: $transport)...${NC}"

  local temp_config=$(mktemp)

  # Base updates (ALL transports) - search by port number, not tag
  jq --argjson port "$port_num" --arg sni "$new_sni" '
    (.inbounds[] | select(.port == $port) | .streamSettings.realitySettings.dest) |= ($sni + ":443") |
    (.inbounds[] | select(.port == $port) | .streamSettings.realitySettings.serverNames) |= [$sni]
  ' "$config_file" > "$temp_config"

  if [[ $? -ne 0 ]] || [[ ! -s "$temp_config" ]]; then
    echo -e "${RED}  ✗ Ошибка обновления SNI${NC}"
    rm -f "$temp_config"
    return 1
  fi

  mv "$temp_config" "$config_file"
  chown root:root "$config_file" 2>/dev/null
  chmod 644 "$config_file" 2>/dev/null
  echo -e "${GREEN}  ✓ Reality SNI обновлен → $new_sni${NC}"

  # Transport-specific updates
  if [[ "$transport" == "xhttp" ]]; then
    if safe_jq_write --argjson port "$port_num" --arg sni "$new_sni" '
      (.inbounds[] | select(.port == $port) | .streamSettings.xhttpSettings.host) |= $sni
    ' "$config_file"; then
      echo -e "${GREEN}  ✓ XHTTP host обновлен → $new_sni${NC}"
    else
      echo -e "${RED}  ✗ Ошибка обновления XHTTP host${NC}"
      return 1
    fi
  fi
}

# Безопасная запись через jq — проверяет результат перед перезаписью
# Использование: safe_jq_write "выражение_jq" [аргументы_jq...] "$входной_файл" "$выходной_файл"
# Или для записи в тот же файл: safe_jq_write "выражение_jq" [аргументы_jq...] "$файл"
# Последний аргумент — целевой файл (куда записать), предпоследний — исходный
# Если целевой == исходный, делает mktemp+mv
safe_jq_write() {
  local args=("$@")
  local nargs=${#args[@]}

  # Минимум 2 аргумента: выражение и файл
  if [[ $nargs -lt 2 ]]; then
    echo -e "${RED}  ✗ safe_jq_write: недостаточно аргументов${NC}" >&2
    return 1
  fi

  # Последний аргумент — исходный файл (и он же целевой при in-place)
  local src_file="${args[$((nargs-1))]}"
  local dst_file="$src_file"
  local jq_args=("${args[@]:0:$((nargs-1))}")

  local tmp=$(mktemp)
  if jq "${jq_args[@]}" "$src_file" > "$tmp" 2>/dev/null && [[ -s "$tmp" ]]; then
    mv "$tmp" "$dst_file"
    chown root:root "$dst_file" 2>/dev/null
    chmod 644 "$dst_file" 2>/dev/null
    return 0
  else
    echo -e "${RED}  ✗ Ошибка jq — файл НЕ изменён: $dst_file${NC}" >&2
    rm -f "$tmp"
    return 1
  fi
}

# Open port in UFW firewall (idempotent)
# Args: $1=port, $2=protocol (default: tcp)
# Returns: 0=success, 1=failure
open_firewall_port() {
  local port=$1
  local protocol=${2:-tcp}

  # Validate port number
  if [[ ! "$port" =~ ^[0-9]+$ ]] || [[ $port -lt 1 ]] || [[ $port -gt 65535 ]]; then
    echo -e "${RED}  ✗ Неверный порт: $port${NC}" >&2
    return 1
  fi

  # Check if UFW is installed and active
  if ! command -v ufw &>/dev/null; then
    echo -e "${YELLOW}  ⚠ UFW не установлен${NC}" >&2
    return 1
  fi

  # Check if port already open (idempotent)
  if ufw status | grep -qE "^${port}/${protocol}.*ALLOW"; then
    echo -e "${CYAN}  → Порт ${port}/${protocol} уже открыт${NC}"
    return 0
  fi

  # Open port
  echo -e "${CYAN}  → Открываю порт ${port}/${protocol}...${NC}"
  if ufw allow "${port}/${protocol}" >/dev/null 2>&1; then
    echo -e "${GREEN}  ✓ Порт ${port}/${protocol} открыт${NC}"
    ufw reload >/dev/null 2>&1
    return 0
  else
    echo -e "${RED}  ✗ Ошибка открытия порта${NC}" >&2
    return 1
  fi
}

# Close port in UFW if not used by other profiles
# Args: $1=port, $2=protocol (default: tcp)
close_firewall_port() {
  local port=$1
  local protocol=${2:-tcp}

  # Check if port is still used by any inbound
  local port_in_use=$(jq -r --argjson port "$port" \
    '.inbounds[] | select(.port == $port) | .tag' \
    "$CONFIG_FILE" 2>/dev/null)

  if [[ -n "$port_in_use" ]]; then
    return 0  # Still in use, don't close
  fi

  # Never close default ports
  local default_ports=(22 80 443 8443 2053 2083 2087 8080 2096 8880 9443)
  for dp in "${default_ports[@]}"; do
    [[ "$port" == "$dp" ]] && return 0
  done

  # Close port
  if ufw status | grep -qE "^${port}/${protocol}.*ALLOW"; then
    echo -e "${CYAN}  → Закрываю порт ${port}/${protocol}...${NC}"
    ufw delete allow "${port}/${protocol}" >/dev/null 2>&1
    ufw reload >/dev/null 2>&1
    echo -e "${GREEN}  ✓ Порт закрыт${NC}"
  fi

  return 0
}

# Get list of profile names using a specific port
# Args: $1=port
# Returns: space-separated profile names
get_profiles_on_port() {
  local port=$1
  local profiles=()

  for pf in "$PROFILES_DIR"/*.json; do
    [[ ! -f "$pf" ]] && continue
    [[ "$pf" == *"_test.json" ]] && continue

    local pp=$(jq -r '.port' "$pf" 2>/dev/null)
    if [[ "$pp" == "$port" ]]; then
      profiles+=("$(basename "$pf" .json)")
    fi
  done

  echo "${profiles[@]}"
}

# Update field for all profiles on a specific port
# Args: $1=port, $2=field, $3=value
update_all_profiles_on_port() {
  local port=$1
  local field=$2
  local value=$3

  local profiles=($(get_profiles_on_port "$port"))

  for pname in "${profiles[@]}"; do
    local pfile="$PROFILES_DIR/$pname.json"
    if safe_jq_write --arg f "$field" --arg v "$value" '.[$f] = $v' "$pfile"; then
      echo -e "${CYAN}  → Обновлен: ${YELLOW}$pname${NC}"
    else
      echo -e "${RED}  ✗ Ошибка обновления: ${YELLOW}$pname${NC}"
    fi
  done
}

# Migration function for existing XHTTP profiles
migrate_xhttp_profiles() {
  local migrated=0

  echo -e "${CYAN}Проверка XHTTP профилей для миграции...${NC}"

  for profile_file in "$PROFILES_DIR"/*.json; do
    [[ ! -f "$profile_file" ]] && continue

    local transport=$(jq -r '.transport' "$profile_file")
    [[ "$transport" != "xhttp" ]] && continue

    local profile_sni=$(jq -r '.sni' "$profile_file")
    local port=$(jq -r '.port' "$profile_file")

    # Check if xhttpSettings.host matches profile SNI
    local config_host=$(jq -r --argjson port "$port" \
      '.inbounds[] | select(.port == $port) | .streamSettings.xhttpSettings.host' \
      "$CONFIG_FILE" 2>/dev/null)

    if [[ "$config_host" != "$profile_sni" ]]; then
      echo -e "${YELLOW}  → Миграция XHTTP: $(basename "$profile_file" .json)${NC}"

      if safe_jq_write --argjson port "$port" --arg sni "$profile_sni" '
        (.inbounds[] | select(.port == $port) | .streamSettings.xhttpSettings.host) |= $sni
      ' "$CONFIG_FILE"; then
        ((migrated++))
      fi
    fi
  done

  if [[ $migrated -gt 0 ]]; then
    echo -e "${GREEN}✓ Мигрировано $migrated XHTTP профилей${NC}"
    systemctl restart xray
  else
    echo -e "${GREEN}✓ Миграция не требуется${NC}"
  fi
}

# Migration function for routing configuration (v1.3.2)
# Adds default "direct" rule if missing
migrate_routing_config() {
  echo -e "${CYAN}Проверка конфигурации маршрутизации...${NC}"

  # Check if default direct rule exists
  local has_direct_rule=$(jq -r '
    .routing.rules[] | select(.outboundTag == "direct" and .network == "tcp,udp") | .outboundTag
  ' "$CONFIG_FILE" 2>/dev/null)

  if [[ -z "$has_direct_rule" ]]; then
    echo -e "${YELLOW}  → Добавляю default direct rule...${NC}"

    local temp_config=$(mktemp)
    jq '.routing.rules += [{
      "type": "field",
      "network": "tcp,udp",
      "outboundTag": "direct"
    }]' "$CONFIG_FILE" > "$temp_config"

    if [[ $? -eq 0 ]] && [[ -s "$temp_config" ]]; then
      mv "$temp_config" "$CONFIG_FILE"
      chown root:root "$CONFIG_FILE"
      chmod 644 "$CONFIG_FILE"
      echo -e "${GREEN}  ✓ Маршрутизация исправлена${NC}"
      return 0  # Needs restart
    else
      rm -f "$temp_config"
      echo -e "${RED}  ✗ Ошибка миграции маршрутизации${NC}"
      return 1
    fi
  else
    echo -e "${GREEN}✓ Маршрутизация в порядке${NC}"
    return 1  # No restart needed
  fi
}

# Migration function for XHTTP mode (stream -> auto)
# Fixes sing-box compatibility issues
# NOTE: extra settings preserved — they are critical for DPI bypass
migrate_xhttp_mode() {
  echo -e "${CYAN}Проверка XHTTP mode для миграции...${NC}"

  local migrated=0

  # Check all inbounds with xhttp transport
  local xhttp_ports=$(jq -r '.inbounds[] | select(.streamSettings.network == "xhttp") | .port' "$CONFIG_FILE" 2>/dev/null)

  for port in $xhttp_ports; do
    [[ -z "$port" ]] && continue

    local current_mode=$(jq -r --argjson port "$port" \
      '.inbounds[] | select(.port == $port) | .streamSettings.xhttpSettings.mode' \
      "$CONFIG_FILE" 2>/dev/null)

    if [[ "$current_mode" == "stream" ]]; then
      echo -e "${YELLOW}  → Миграция XHTTP mode на порту $port: stream → auto${NC}"

      local temp_config=$(mktemp)
      jq --argjson port "$port" '
        (.inbounds[] | select(.port == $port) | .streamSettings.xhttpSettings.mode) = "auto"
      ' "$CONFIG_FILE" > "$temp_config"

      if [[ $? -eq 0 ]] && [[ -s "$temp_config" ]]; then
        mv "$temp_config" "$CONFIG_FILE"
        ((migrated++))
      else
        rm -f "$temp_config"
      fi
    fi
  done

  if [[ $migrated -gt 0 ]]; then
    chown root:root "$CONFIG_FILE"
    chmod 644 "$CONFIG_FILE"
    echo -e "${GREEN}✓ Мигрировано $migrated XHTTP inbound(ов)${NC}"
    return 0  # Needs restart
  else
    echo -e "${GREEN}✓ XHTTP mode миграция не требуется${NC}"
    return 1  # No restart needed
  fi
}

# Migration: restore XHTTP extra settings wiped by previous migrate_xhttp_mode bug
# Without extra (padding, xmux, post limits) XHTTP is easily detected by DPI
migrate_xhttp_extra_restore() {
  echo -e "${CYAN}Проверка XHTTP extra для восстановления...${NC}"

  local restored=0

  local xhttp_ports=$(jq -r '.inbounds[] | select(.streamSettings.network == "xhttp") | .port' "$CONFIG_FILE" 2>/dev/null)

  for port in $xhttp_ports; do
    [[ -z "$port" ]] && continue

    # Check if extra is missing, null, or empty object
    local extra_keys=$(jq -r --argjson port "$port" \
      '.inbounds[] | select(.port == $port) | .streamSettings.xhttpSettings.extra // {} | keys | length' \
      "$CONFIG_FILE" 2>/dev/null)

    if [[ "$extra_keys" == "0" ]] || [[ -z "$extra_keys" ]]; then
      echo -e "${YELLOW}  → Восстановление XHTTP extra на порту $port${NC}"

      local temp_config=$(mktemp)
      jq --argjson port "$port" '
        (.inbounds[] | select(.port == $port) | .streamSettings.xhttpSettings.extra) = {
          "xPaddingBytes": "100-1000",
          "xmux": {
            "maxConcurrency": "16-32",
            "cMaxLifetimeMs": "10000-30000"
          },
          "noSSEHeader": true,
          "scMaxEachPostBytes": "1000000-2000000",
          "scMinPostsIntervalMs": "10-50"
        }
      ' "$CONFIG_FILE" > "$temp_config"

      if [[ $? -eq 0 ]] && [[ -s "$temp_config" ]]; then
        mv "$temp_config" "$CONFIG_FILE"
        ((restored++))
      else
        rm -f "$temp_config"
      fi
    fi
  done

  if [[ $restored -gt 0 ]]; then
    chown root:root "$CONFIG_FILE"
    chmod 644 "$CONFIG_FILE"
    echo -e "${GREEN}✓ Восстановлено extra для $restored XHTTP inbound(ов)${NC}"
    return 0  # Needs restart
  else
    echo -e "${GREEN}✓ XHTTP extra в порядке${NC}"
    return 1  # No restart needed
  fi
}

# ═══════════════════════════════════════════════════════════
# END HELPER FUNCTIONS
# ═══════════════════════════════════════════════════════════

SERVER_IP=$(get_server_ip)


# Показать ASCII арт
show_ascii() {
  clear
  local ASCII_URL="https://raw.githubusercontent.com/howdeploy/Xrayebator/main/ascii_art.txt"
  if [[ ! -f "$ASCII_ART" ]]; then
    mkdir -p "$(dirname "$ASCII_ART")"
    curl -fsSL "$ASCII_URL" -o "$ASCII_ART" 2>/dev/null || true
  fi
  if [[ -f "$ASCII_ART" ]] && [[ -s "$ASCII_ART" ]]; then
    echo -e "${CYAN}"
    cat "$ASCII_ART"
    echo -e "${NC}"
  else
    echo -e "${CYAN}"
    echo ' ╔═══════════════════════════════════╗'
    echo ' ║                                   ║'
    echo ' ║     XRAYEBATOR v1.3.2 EXP        ║'
    echo ' ║   Xray Reality VPN Manager       ║'
    echo ' ║                                   ║'
    echo ' ╚═══════════════════════════════════╝'
    echo -e "${NC}"
  fi
  echo ""
}

# Главное меню
main_menu() {
  # Run migrations on first launch after upgrade
  local needs_restart=false

  if [[ ! -f /usr/local/etc/xray/.xhttp_migrated ]]; then
    if migrate_xhttp_profiles; then
      touch /usr/local/etc/xray/.xhttp_migrated
      needs_restart=true
    fi
  fi

  # v1.3.2: Routing migration
  if [[ ! -f /usr/local/etc/xray/.routing_v132_migrated ]]; then
    if migrate_routing_config; then
      touch /usr/local/etc/xray/.routing_v132_migrated
      needs_restart=true
    fi
  fi

  # XHTTP mode migration (stream -> auto for sing-box compatibility)
  if [[ ! -f /usr/local/etc/xray/.xhttp_mode_migrated ]]; then
    if migrate_xhttp_mode; then
      touch /usr/local/etc/xray/.xhttp_mode_migrated
      needs_restart=true
    fi
  fi

  # XHTTP extra restore (fix for previous migration that wiped anti-DPI settings)
  if [[ ! -f /usr/local/etc/xray/.xhttp_extra_restored ]]; then
    if migrate_xhttp_extra_restore; then
      touch /usr/local/etc/xray/.xhttp_extra_restored
      needs_restart=true
    fi
  fi

  if [[ "$needs_restart" == "true" ]]; then
    echo -e "${CYAN}Перезапуск Xray после миграций...${NC}"
    systemctl restart xray
    sleep 2
  fi

  while true; do
    show_ascii

    # Показываем текущую ветку
    local current_branch=$(cat /usr/local/etc/xray/.current_branch 2>/dev/null || echo "main")
    case $current_branch in
      main)
        echo -e "${GREEN}[Stable]${NC} Стабильная версия"
        ;;
      dev)
        echo -e "${BLUE}[Dev]${NC} Версия с быстрыми фиксами"
        ;;
      experimental)
        echo -e "${MAGENTA}[Experimental]${NC} Экспериментальная версия"
        ;;
    esac
    echo ""

    echo -e "${BLUE}╔════════════════════════════════════════╗${NC}"
    echo -e "${BLUE}║            ГЛАВНОЕ МЕНЮ                ║${NC}"
    echo -e "${BLUE}╚════════════════════════════════════════╝${NC}"
    echo ""
    echo -e "${CYAN} 1)${NC} Создать новый профиль"
    echo -e "${CYAN} 2)${NC} Удалить существующий профиль"
    echo -e "${CYAN} 3)${NC} Подключиться по профилю"
    echo ""
    echo -e "${MAGENTA} НАСТРОЙКИ МАСКИРОВКИ:${NC}"
    echo -e "${CYAN} 4)${NC} Подменить SNI профиля (домен маскировки)"
    echo -e "${CYAN} 5)${NC} Подменить Fingerprint профиля (браузер)"
    echo -e "${CYAN} 6)${NC} Изменить порт профиля"
    echo ""
    echo -e "${MAGENTA} ДОПОЛНИТЕЛЬНЫЕ ФУНКЦИИ:${NC}"
    echo -e "${CYAN} 7)${NC} AdGuard Home (блокировка рекламы)"
    echo ""
    echo -e "${RED} 0)${NC} Выход"
    echo ""
    echo -e "${BLUE}╚════════════════════════════════════════╝${NC}"
    echo -n -e "${YELLOW}Выберите действие: ${NC}"
    read choice
    case $choice in
      1) create_profile_menu ;;
      2) delete_profile_menu ;;
      3) connect_profile_menu ;;
      4) change_sni_menu ;;
      5) change_fingerprint_menu ;;
      6) change_port_menu ;;
      7) adguard_home_menu ;;
      0) exit 0 ;;
      *) echo -e "${RED}Неверный выбор${NC}"; sleep 1 ;;
    esac
  done
}

# Меню создания профиля
create_profile_menu() {
  show_ascii
  echo -e "${BLUE}═══════════════════════════════════════════════${NC}"
  echo -e "${BLUE}        СОЗДАНИЕ НОВОГО ПРОФИЛЯ               ${NC}"
  echo -e "${BLUE}═══════════════════════════════════════════════${NC}\n"
  echo -n -e "${YELLOW}Введите имя профиля (или 0 для отмены): ${NC}"
  read profile_name
  if [[ "$profile_name" == "0" ]]; then
    return
  fi
  if [[ -z "$profile_name" ]]; then
    echo -e "${RED}✗ Имя не может быть пустым${NC}"
    sleep 2
    return
  fi
  if [[ ! "$profile_name" =~ ^[a-zA-Z0-9_-]+$ ]]; then
    echo -e "${RED}✗ Используйте только буквы, цифры, дефис и подчеркивание${NC}"
    sleep 2
    return
  fi
  if [[ -f "$PROFILES_DIR/$profile_name.json" ]]; then
    echo -e "${RED}✗ Профиль с таким именем уже существует${NC}"
    sleep 2
    return
  fi
  echo ""
  echo -e "${BLUE}╔════════════════════════════════════════════════════════════╗${NC}"
  echo -e "${BLUE}║              ВЫБЕРИТЕ ТИП МАРШРУТА                        ║${NC}"
  echo -e "${BLUE}╚════════════════════════════════════════════════════════════╝${NC}"
  echo ""
  echo -e "${CYAN} 1)${NC} VLESS + TCP + Reality + Mux ${GREEN}(порт 443)${NC} ${MAGENTA}— РЕКОМЕНДУЕТСЯ${NC}"
  echo -e "    ${GREEN}✓${NC} Обходит блокировку Vision по паттерну множественных TLS"
  echo -e "    ${GREEN}✓${NC} Мультиплексирование на стороне клиента"
  echo -e "    ${GREEN}✓${NC} Безопасен на мобильных сетях (без >15KB детекции)"
  echo ""
  echo -e "${CYAN} 2)${NC} VLESS + TCP + Reality + Vision ${YELLOW}(порт 8443)${NC}"
  echo -e "    ${GREEN}✓${NC} Стабильный и быстрый"
  echo -e "    ${GREEN}✓${NC} Маскируется под обычный HTTPS трафик"
  echo -e "    ${YELLOW}⚠${NC} Vision на 443 детектируется ТСПУ (декабрь 2025+)"
  echo ""
  echo -e "${CYAN} 3)${NC} VLESS + TCP + Reality + Vision + uTLS ${MAGENTA}(порт 8443, Firefox)${NC}"
  echo -e "    ${GREEN}✓${NC} Трафик маскируется под Firefox HTTPS"
  echo -e "    ${GREEN}✓${NC} Решает проблему TLS fingerprint"
  echo -e "    ${GREEN}✓${NC} TCP BBR congestion control"
  echo -e "    ${BLUE}ℹ${NC} Идеален для обхода продвинутой DPI фильтрации"
  echo ""
  echo -e "${CYAN} 4)${NC} VLESS + gRPC + Reality ${YELLOW}(порт 2053)${NC}"
  echo -e "    ${YELLOW}⚠${NC} Требует SNI с поддержкой HTTP/2 (google.com, cloudflare.com)"
  echo -e "    ${YELLOW}⚠${NC} РУ-домены (госуслуги, сбер) часто НЕ работают!"
  echo -e "    ${YELLOW}⚠${NC} Проблемы совместимости с sing-box"
  echo ""
  echo -e "${CYAN} 5)${NC} VLESS + XHTTP + Reality ${GREEN}(порт 9443)${NC}"
  echo -e "    ${GREEN}✓${NC} Современный протокол с низкой задержкой"
  echo -e "    ${GREEN}✓${NC} Padding + xmux для минимизации обнаружения"
  echo -e "    ${YELLOW}⚠${NC} Требует клиенты с поддержкой XHTTP"
  echo ""
  echo -e "${CYAN} 6)${NC} VLESS + TCP + Reality + Vision + XUDP ${GREEN}(порт 443, anti-Tele2)${NC}"
  echo -e "    ${GREEN}✓${NC} Обходит жесткие блокировки Tele2"
  echo -e "    ${GREEN}✓${NC} xtls-rprx-vision + xudp"
  echo -e "    ${GREEN}✓${NC} SNI: api-maps.yandex.ru по умолчанию"
  echo -e "    ${BLUE}ℹ${NC} Специальная конфигурация против DPI"
  echo ""
  echo -e "${CYAN} 0)${NC} Назад в главное меню"
  echo ""
  echo -e "${BLUE}╚════════════════════════════════════════════════════════════╝${NC}"
  echo -n -e "${YELLOW}Ваш выбор: ${NC}"
  read route_choice
  case $route_choice in
    1) create_profile "$profile_name" "tcp-mux" "443" "chrome" ;;
    2) create_profile "$profile_name" "tcp" "8443" "chrome" ;;
    3) create_profile "$profile_name" "tcp-utls" "8443" "firefox" ;;
    4) create_profile "$profile_name" "grpc" "2053" "chrome" ;;
    5) create_profile "$profile_name" "xhttp" "9443" "chrome" ;;
    6) create_profile "$profile_name" "tcp-xudp" "443" "chrome" "api-maps.yandex.ru" ;;
    0) return ;;
    *) echo -e "${RED}Неверный выбор${NC}"; sleep 2; return ;;
  esac
}

# Создание профиля
create_profile() {
  local name=$1
  local transport=$2
  local port=$3
  local fingerprint=$4

local custom_sni=$5  # Опциональный кастомный SNI
  local uuid=$(uuidgen)

  local default_sni=""

  # gRPC требует SNI с поддержкой HTTP/2 (только зарубежные!)
  if [[ "$transport" == "grpc" ]]; then
    default_sni="www.google.com"
    echo -e "${YELLOW}⚠ gRPC: используется SNI ${CYAN}$default_sni${YELLOW} (требуется HTTP/2)${NC}"
  else
    # Read first valid SNI (skip comments and empty lines)
    default_sni=$(grep -v '^#' "$SNI_LIST" 2>/dev/null | grep -v '^[[:space:]]*$' | head -n 1 | cut -d'|' -f1)
    [[ -z "$default_sni" ]] && default_sni="www.microsoft.com"
  fi

# Используем кастомный SNI если передан

[[ -n "$custom_sni" ]] && default_sni="$custom_sni"

  cat > "$PROFILES_DIR/$name.json" << EOF
{
  "name": "$name",
  "uuid": "$uuid",
  "transport": "$transport",
  "port": "$port",
  "fingerprint": "$fingerprint",
  "sni": "$default_sni",
  "created": "$(date +%Y-%m-%d\ %H:%M:%S)"
}
EOF

  if ! add_inbound "$uuid" "$transport" "$port" "$default_sni" "$fingerprint"; then
    rm -f "$PROFILES_DIR/$name.json"
    echo ""
    echo -e "${RED}╔═══════════════════════════════════════════════${NC}"
    echo -e "${RED}         ✗ ОШИБКА СОЗДАНИЯ ПРОФИЛЯ            ${NC}"
    echo -e "${RED}╚═══════════════════════════════════════════════${NC}"
    echo ""
    echo -e "${RED}Inbound не создан — файл профиля удалён.${NC}"
    echo -e "${YELLOW}Попробуйте другой порт или транспорт.${NC}"
    echo ""
    echo -n -e "${YELLOW}Нажмите Enter для продолжения...${NC}"
    read
    return 1
  fi

  systemctl restart xray

  # Читаем актуальный SNI из файла (мог измениться при SNI-конфликте)
  local actual_sni=$(jq -r '.sni' "$PROFILES_DIR/$name.json" 2>/dev/null)
  [[ -z "$actual_sni" ]] && actual_sni="$default_sni"

  echo ""
  echo -e "${GREEN}╔═══════════════════════════════════════════════${NC}"
  echo -e "${GREEN}         ✓ ПРОФИЛЬ УСПЕШНО СОЗДАН!            ${NC}"
  echo -e "${GREEN}╚═══════════════════════════════════════════════${NC}"
  echo ""
  echo -e "${BLUE}Имя профиля:${NC} ${GREEN}$name${NC}"
  echo -e "${BLUE}UUID:${NC} $uuid"
  echo -e "${BLUE}Транспорт:${NC} $transport"
  echo -e "${BLUE}Порт:${NC} $port"
  echo -e "${BLUE}Fingerprint:${NC} $fingerprint"
  echo -e "${BLUE}SNI:${NC} $actual_sni"
  echo ""
  echo -e "${CYAN}Используйте меню 'Подключиться по профилю' для получения ссылки${NC}"
  echo ""
  echo -n -e "${YELLOW}Нажмите Enter для продолжения...${NC}"
  read
}

# Добавление inbound
add_inbound() {
  local uuid=$1
  local transport=$2
  local port=$3
  local sni=$4
  local fingerprint=${5:-"chrome"}

  local existing_tag=$(jq -r --argjson port "$port" '.inbounds[] | select(.port == $port) | .tag' "$CONFIG_FILE" 2>/dev/null)
  if [[ -n "$existing_tag" ]]; then
    # Check transport compatibility
    local existing_transport=$(jq -r --argjson port "$port" \
      '.inbounds[] | select(.port == $port) | .streamSettings.network' \
      "$CONFIG_FILE" 2>/dev/null)

    local expected_network="$transport"
    case "$transport" in
      tcp|tcp-utls|tcp-xudp|tcp-mux) expected_network="tcp" ;;
    esac

    if [[ -n "$existing_transport" ]] && [[ "$expected_network" != "$existing_transport" ]]; then
      echo ""
      echo -e "${RED}✗ Порт $port уже используется с транспортом '$existing_transport' (несовместимо с '$transport')${NC}"
      echo -e "${YELLOW}Используйте другой порт для транспорта '$transport'${NC}"
      return 1
    fi

    # Check existing inbound's SNI
    local existing_sni=$(jq -r --argjson port "$port" \
      '.inbounds[] | select(.port == $port) | .streamSettings.realitySettings.serverNames[0]' \
      "$CONFIG_FILE" 2>/dev/null)

    if [[ -n "$existing_sni" ]] && [[ "$existing_sni" != "$sni" ]]; then
      echo ""
      echo -e "${RED}╔═══════════════════════════════════════════════════════════╗${NC}"
      echo -e "${RED}║         ⚠ КОНФЛИКТ SNI НА ПОРТУ $port                    ║${NC}"
      echo -e "${RED}╚═══════════════════════════════════════════════════════════╝${NC}"
      echo ""
      echo -e "${YELLOW}Порт $port уже используется с SNI: ${MAGENTA}$existing_sni${NC}"
      echo -e "${YELLOW}Новый профиль пытается использовать SNI: ${MAGENTA}$sni${NC}"
      echo ""
      echo -e "${CYAN}Xray Reality не поддерживает разные SNI на одном порту.${NC}"
      echo -e "${CYAN}Профиль будет создан с SNI: ${YELLOW}$existing_sni${NC}"
      echo ""
      sleep 3

      # Override sni to match existing inbound
      sni="$existing_sni"

      # Обновить SNI в только что созданном файле профиля
      local pf
      for pf in "$PROFILES_DIR"/*.json; do
        [[ ! -f "$pf" ]] && continue
        local pf_uuid=$(jq -r '.uuid' "$pf" 2>/dev/null)
        if [[ "$pf_uuid" == "$uuid" ]]; then
          safe_jq_write --arg sni "$existing_sni" '.sni = $sni' "$pf" || \
            echo -e "${YELLOW}  ⚠ Не удалось обновить SNI в профиле$(basename "$pf")${NC}"
          break
        fi
      done
    fi

    # Синхронизация fingerprint с существующим inbound
    local existing_fp=$(jq -r --argjson port "$port" \
      '.inbounds[] | select(.port == $port) | .streamSettings.realitySettings.fingerprint' \
      "$CONFIG_FILE" 2>/dev/null)

    if [[ -n "$existing_fp" ]] && [[ "$existing_fp" != "$fingerprint" ]]; then
      echo -e "${YELLOW}⚠ Fingerprint порта $port: ${CYAN}$existing_fp${YELLOW} (профиль будет обновлён)${NC}"
      fingerprint="$existing_fp"
      # Обновить fingerprint в только что созданном файле профиля
      local fpf
      for fpf in "$PROFILES_DIR"/*.json; do
        [[ ! -f "$fpf" ]] && continue
        local fpf_uuid=$(jq -r '.uuid' "$fpf" 2>/dev/null)
        if [[ "$fpf_uuid" == "$uuid" ]]; then
          safe_jq_write --arg fp "$existing_fp" '.fingerprint = $fp' "$fpf"
          break
        fi
      done
    fi

    echo -e "${CYAN} → Добавление клиента в существующий inbound на порту $port${NC}"
    # Определяем flow по типу транспорта нового профиля (не копируем слепо от первого клиента)
    local client_flow=""
    case "$transport" in
      tcp|tcp-utls|tcp-xudp) client_flow="xtls-rprx-vision" ;;
      tcp-mux|grpc|xhttp) client_flow="" ;;
    esac
    if ! safe_jq_write --arg uuid "$uuid" --argjson port "$port" --arg flow "$client_flow" '
      (.inbounds[] | select(.port == $port) | .settings.clients) += [{
        "id": $uuid,
        "flow": $flow
      }]
    ' "$CONFIG_FILE"; then
      echo -e "${RED}  ✗ Не удалось добавить клиента в inbound${NC}"
      return 1
    fi
    return
  fi

  echo -e "${CYAN} → Создание нового inbound на порту $port${NC}"
  local inbound=""
  case $transport in
    tcp-mux)
      inbound=$(cat << TCPMUXEOF
{
  "listen": "0.0.0.0",
  "port": $port,
  "protocol": "vless",
  "settings": {
    "clients": [{"id": "$uuid", "flow": ""}],
    "decryption": "none"
  },
  "streamSettings": {
    "network": "tcp",
    "security": "reality",
    "realitySettings": {
      "show": false,
      "dest": "$sni:443",
      "xver": 0,
      "serverNames": ["$sni"],
      "privateKey": "$PRIVATE_KEY",
      "shortIds": [""],
      "fingerprint": "$fingerprint"
    }
  },
  "sniffing": {"enabled": true, "destOverride": ["http", "tls", "quic"]},
  "tag": "inbound-$port"
}
TCPMUXEOF
)
      ;;
    tcp|tcp-utls|tcp-xudp)
      inbound=$(cat << TCPEOF
{
  "listen": "0.0.0.0",
  "port": $port,
  "protocol": "vless",
  "settings": {
    "clients": [{"id": "$uuid", "flow": "xtls-rprx-vision"}],
    "decryption": "none"
  },
  "streamSettings": {
    "network": "tcp",
    "security": "reality",
    "realitySettings": {
      "show": false,
      "dest": "$sni:443",
      "xver": 0,
      "serverNames": ["$sni"],
      "privateKey": "$PRIVATE_KEY",
      "shortIds": [""],
      "fingerprint": "$fingerprint"
    }
  },
  "sniffing": {"enabled": true, "destOverride": ["http", "tls", "quic"]},
  "tag": "inbound-$port"
}
TCPEOF
)
      ;;
    grpc)
      inbound=$(cat << GRPCEOF
{
  "listen": "0.0.0.0",
  "port": $port,
  "protocol": "vless",
  "settings": {
    "clients": [{"id": "$uuid", "flow": ""}],
    "decryption": "none"
  },
  "streamSettings": {
    "network": "grpc",
    "security": "reality",
    "grpcSettings": {"serviceName": "grpc"},
    "realitySettings": {
      "show": false,
      "dest": "$sni:443",
      "xver": 0,
      "serverNames": ["$sni"],
      "privateKey": "$PRIVATE_KEY",
      "shortIds": [""],
      "fingerprint": "$fingerprint"
    }
  },
  "sniffing": {"enabled": true, "destOverride": ["http", "tls", "quic"]},
  "tag": "inbound-$port"
}
GRPCEOF
)
      ;;
    xhttp)
      inbound=$(cat << XHTTPEOF
{
  "listen": "0.0.0.0",
  "port": $port,
  "protocol": "vless",
  "settings": {
    "clients": [{"id": "$uuid", "flow": ""}],
    "decryption": "none"
  },
  "streamSettings": {
    "network": "xhttp",
    "security": "reality",
    "xhttpSettings": {
      "mode": "auto",
      "path": "/xhttp",
      "host": "$sni",
      "extra": {
        "xPaddingBytes": "100-1000",
        "xmux": {
          "maxConcurrency": "16-32",
          "cMaxLifetimeMs": "10000-30000"
        },
        "noSSEHeader": true,
        "scMaxEachPostBytes": "1000000-2000000",
        "scMinPostsIntervalMs": "10-50"
      }
    },
    "realitySettings": {
      "show": false,
      "dest": "$sni:443",
      "xver": 0,
      "serverNames": ["$sni"],
      "privateKey": "$PRIVATE_KEY",
      "shortIds": [""],
      "fingerprint": "$fingerprint"
    }
  },
  "sniffing": {"enabled": true, "destOverride": ["http", "tls", "quic"]},
  "tag": "inbound-$port"
}
XHTTPEOF
)
      ;;
  esac

  if ! safe_jq_write ".inbounds += [$inbound]" "$CONFIG_FILE"; then
    echo -e "${RED}  ✗ Не удалось создать inbound в конфиге${NC}"
    return 1
  fi

  # Open firewall port
  open_firewall_port "$port"
}

# Удаление профиля
delete_profile_menu() {
  show_ascii
  echo -e "${BLUE}═══════════════════════════════════════════════${NC}"
  echo -e "${BLUE}             УДАЛЕНИЕ ПРОФИЛЯ                 ${NC}"
  echo -e "${BLUE}═══════════════════════════════════════════════${NC}\n"
  local profiles=($(ls -1 "$PROFILES_DIR" 2>/dev/null | sed 's/.json//'))
  if [[ ${#profiles[@]} -eq 0 ]]; then
    echo -e "${RED}✗ Нет созданных профилей${NC}"
    echo ""
    echo -n -e "${YELLOW}Нажмите Enter для продолжения...${NC}"
    read
    return
  fi
  echo -e "${YELLOW}Доступные профили:${NC}\n"
  local i=1
  for profile in "${profiles[@]}"; do
    local transport=$(jq -r '.transport' "$PROFILES_DIR/$profile.json" 2>/dev/null)
    local port=$(jq -r '.port' "$PROFILES_DIR/$profile.json" 2>/dev/null)
    echo -e "${CYAN} $i)${NC} $profile ${BLUE}[$transport:$port]${NC}"
    ((i++))
  done
  echo -e "${CYAN} 0)${NC} Назад в главное меню\n"
  echo -n -e "${YELLOW}Выберите профиль для удаления: ${NC}"
  read choice
  if [[ "$choice" == "0" ]]; then
    return
  fi
  if [[ "$choice" =~ ^[0-9]+$ ]] && [[ $choice -ge 1 ]] && [[ $choice -le ${#profiles[@]} ]]; then
    local profile_name="${profiles[$((choice-1))]}"
    echo ""
    echo -n -e "${RED}Вы уверены, что хотите удалить профиль '$profile_name'? (y/N): ${NC}"
    read confirm
    if [[ "$confirm" =~ ^[yYдД]$ ]]; then
      local port=$(jq -r '.port' "$PROFILES_DIR/$profile_name.json")
      local uuid=$(jq -r '.uuid' "$PROFILES_DIR/$profile_name.json")

      # Считаем клиентов через config.json (надёжнее чем файлы профилей)
      local clients_count=$(jq -r --argjson port "$port" \
        '.inbounds[] | select(.port == $port) | .settings.clients | length' \
        "$CONFIG_FILE" 2>/dev/null)
      [[ -z "$clients_count" ]] && clients_count=0

      local config_ok=false
      if [[ "$clients_count" -le 1 ]]; then
        # Единственный клиент (или inbound отсутствует) — удаляем весь inbound
        if safe_jq_write --argjson port "$port" 'del(.inbounds[] | select(.port == $port))' "$CONFIG_FILE"; then
          echo -e "${CYAN}  → Удаление inbound на порту $port${NC}"
          config_ok=true
        fi
      else
        # Есть другие клиенты — удаляем только этого (scoped по порту)
        if safe_jq_write --arg uuid "$uuid" --argjson port "$port" '
          (.inbounds[] | select(.port == $port) | .settings.clients) |= map(select(.id != $uuid))
        ' "$CONFIG_FILE"; then
          echo -e "${CYAN}  → Удаление клиента из inbound (порт $port используется другими профилями)${NC}"
          config_ok=true
        fi
      fi

      if [[ "$config_ok" == "true" ]]; then
        rm -f "$PROFILES_DIR/$profile_name.json"

        # Close firewall port if not used by other profiles
        close_firewall_port "$port"

        systemctl restart xray
        echo ""
        echo -e "${GREEN}✓ Профиль '$profile_name' успешно удален${NC}"
      else
        echo ""
        echo -e "${RED}✗ Ошибка обновления конфига — профиль НЕ удалён${NC}"
      fi
    else
      echo -e "${YELLOW}⚠ Удаление отменено${NC}"
    fi
  else
    echo -e "${RED}✗ Неверный выбор${NC}"
  fi
  echo ""
  echo -n -e "${YELLOW}Нажмите Enter для продолжения...${NC}"
  read
}

# Подключение к профилю
connect_profile_menu() {
  show_ascii
  echo -e "${BLUE}═══════════════════════════════════════════════${NC}"
  echo -e "${BLUE}          ПОДКЛЮЧЕНИЕ К ПРОФИЛЮ               ${NC}"
  echo -e "${BLUE}═══════════════════════════════════════════════${NC}\n"
  local profiles=($(ls -1 "$PROFILES_DIR" 2>/dev/null | sed 's/.json//'))
  if [[ ${#profiles[@]} -eq 0 ]]; then
    echo -e "${RED}✗ Нет созданных профилей${NC}"
    echo -e "${CYAN}Создайте профиль через меню 'Создать новый профиль'${NC}"
    echo ""
    echo -n -e "${YELLOW}Нажмите Enter для продолжения...${NC}"
    read
    return
  fi
  echo -e "${YELLOW}Доступные профили:${NC}\n"
  local i=1
  for profile in "${profiles[@]}"; do
    local transport=$(jq -r '.transport' "$PROFILES_DIR/$profile.json" 2>/dev/null)
    local port=$(jq -r '.port' "$PROFILES_DIR/$profile.json" 2>/dev/null)
    echo -e "${CYAN} $i)${NC} $profile ${BLUE}[$transport:$port]${NC}"
    ((i++))
  done
  echo -e "${CYAN} 0)${NC} Назад в главное меню\n"
  echo -n -e "${YELLOW}Выберите профиль: ${NC}"
  read choice
  if [[ "$choice" == "0" ]]; then
    return
  fi
  if [[ "$choice" =~ ^[0-9]+$ ]] && [[ $choice -ge 1 ]] && [[ $choice -le ${#profiles[@]} ]]; then
    local profile_name="${profiles[$((choice-1))]}"
    generate_connection "$profile_name"
  else
    echo -e "${RED}✗ Неверный выбор${NC}"
    sleep 2
  fi
}

# Генерация данных подключения
generate_connection() {
  local profile_name=$1
  local profile_file="$PROFILES_DIR/$profile_name.json"
  local uuid=$(jq -r '.uuid' "$profile_file")
  local transport=$(jq -r '.transport' "$profile_file")
  local port=$(jq -r '.port' "$profile_file")
  local fingerprint=$(jq -r '.fingerprint // "chrome"' "$profile_file")
  local current_sni=$(jq -r '.sni // "www.microsoft.com"' "$profile_file")
  local clean_public_key=$(cat "$PUBLIC_KEY_FILE")

  show_ascii
  echo -e "${GREEN}═══════════════════════════════════════════════${NC}"
  echo -e "${GREEN}    ДАННЫЕ ДЛЯ ПОДКЛЮЧЕНИЯ: $profile_name${NC}"
  echo -e "${GREEN}═══════════════════════════════════════════════${NC}\n"
  local vless_link=""
  case $transport in
    tcp|tcp-utls|tcp-xudp)
      # TCP Reality + Vision
      vless_link="vless://${uuid}@${SERVER_IP}:${port}?encryption=none&flow=xtls-rprx-vision&security=reality&sni=${current_sni}&fp=${fingerprint}&pbk=${clean_public_key}&sid=&type=tcp&headerType=none#${profile_name}"
      ;;
    tcp-mux)
      # TCP Reality + Mux (без Vision, мультиплексирование на клиенте)
      vless_link="vless://${uuid}@${SERVER_IP}:${port}?encryption=none&security=reality&sni=${current_sni}&fp=${fingerprint}&pbk=${clean_public_key}&sid=&type=tcp&headerType=none#${profile_name}"
      ;;
    grpc)
      # gRPC Reality
      vless_link="vless://${uuid}@${SERVER_IP}:${port}?encryption=none&security=reality&sni=${current_sni}&fp=${fingerprint}&pbk=${clean_public_key}&sid=&type=grpc&serviceName=grpc#${profile_name}"
      ;;
    xhttp)
      # XHTTP Reality - требует современные клиенты (sing-box 1.8+, v2rayN 6.x+)
      vless_link="vless://${uuid}@${SERVER_IP}:${port}?encryption=none&security=reality&sni=${current_sni}&fp=${fingerprint}&pbk=${clean_public_key}&sid=&type=xhttp&path=%2Fxhttp&host=${current_sni}#${profile_name}"
      ;;
  esac
  echo -e "${BLUE}Ссылка для подключения:${NC}"
  echo -e "${YELLOW}${vless_link}${NC}\n"
  echo -e "${BLUE}QR-код:${NC}\n"
  qrencode -t ANSIUTF8 "$vless_link"
  echo ""
  echo -e "${GREEN}═══════════════════════════════════════════════${NC}"
  echo -e "${CYAN}Параметры для ручной настройки:${NC}"
  echo ""
  echo -e "${CYAN}Адрес:${NC} $SERVER_IP"
  echo -e "${CYAN}Порт:${NC} $port"
  echo -e "${CYAN}UUID:${NC} $uuid"
  case $transport in
    tcp|tcp-utls|tcp-xudp)
      echo -e "${CYAN}Flow:${NC} xtls-rprx-vision"
      ;;
    tcp-mux)
      echo -e "${CYAN}Flow:${NC} (пустой)"
      echo -e "${CYAN}Mux:${NC} включить на клиенте (sing-box: multiplex, v2rayN: mux)"
      ;;
    grpc|xhttp)
      echo -e "${CYAN}Flow:${NC} (пустой)"
      ;;
  esac
  echo -e "${CYAN}Encryption:${NC} none"
  echo -e "${CYAN}Transport:${NC} $transport"
  echo -e "${CYAN}Security:${NC} reality"
  echo -e "${CYAN}SNI:${NC} $current_sni"
  echo -e "${CYAN}Fingerprint:${NC} $fingerprint"
  echo -e "${CYAN}PublicKey:${NC} $clean_public_key"
  echo -e "${CYAN}ShortID:${NC} (пустой)"
  if [[ "$transport" == "tcp" ]] || [[ "$transport" == "tcp-utls" ]] || [[ "$transport" == "tcp-xudp" ]] || [[ "$transport" == "tcp-mux" ]]; then
    echo -e "${CYAN}SpiderX:${NC} /"
  elif [[ "$transport" == "grpc" ]]; then
    echo -e "${CYAN}serviceName:${NC} grpc"
  elif [[ "$transport" == "xhttp" ]]; then
    echo -e "${CYAN}Path:${NC} /xhttp"
    echo -e "${CYAN}Host:${NC} $current_sni"
    echo ""
    echo -e "${YELLOW}⚠ XHTTP требует современные клиенты:${NC}"
    echo -e "  ${GREEN}✓${NC} sing-box 1.8+, v2rayN 6.x+, v2rayNG 1.8.x+"
    echo -e "  ${RED}✗${NC} Clash Meta, старые версии клиентов"
  fi
  echo -e "${GREEN}═══════════════════════════════════════════════${NC}\n"
  echo -n -e "${YELLOW}Нажмите Enter для продолжения...${NC}"
  read
}

# Смена SNI
change_sni_menu() {
  show_ascii
  echo -e "${BLUE}═══════════════════════════════════════════════${NC}"
  echo -e "${BLUE}    ПОДМЕНА SNI ПРОФИЛЯ (МАСКИРОВКА)         ${NC}"
  echo -e "${BLUE}═══════════════════════════════════════════════${NC}\n"

  local profiles=($(ls -1 "$PROFILES_DIR" 2>/dev/null | sed 's/.json//'))
  if [[ ${#profiles[@]} -eq 0 ]]; then
    echo -e "${RED}✗ Нет созданных профилей${NC}"
    echo ""
    echo -n -e "${YELLOW}Нажмите Enter для продолжения...${NC}"
    read
    return
  fi

  echo -e "${YELLOW}Выберите профиль для смены SNI:${NC}\n"
  local i=1
  for profile in "${profiles[@]}"; do
    local sni=$(jq -r '.sni // "не задан"' "$PROFILES_DIR/$profile.json" 2>/dev/null)
    local port=$(jq -r '.port' "$PROFILES_DIR/$profile.json" 2>/dev/null)
    echo -e "${CYAN} $i)${NC} $profile ${BLUE}[порт:$port]${NC} ${YELLOW}[SNI:$sni]${NC}"
    ((i++))
  done
  echo -e "${CYAN} 0)${NC} Назад в главное меню\n"

  echo -n -e "${YELLOW}Выберите профиль: ${NC}"
  read choice

  if [[ "$choice" == "0" ]]; then
    return
  fi

  if [[ ! "$choice" =~ ^[0-9]+$ ]] || [[ $choice -lt 1 ]] || [[ $choice -gt ${#profiles[@]} ]]; then
    echo -e "${RED}✗ Неверный выбор${NC}"
    sleep 2
    return
  fi

  local selected="${profiles[$((choice-1))]}"
  local current_sni=$(jq -r '.sni // "www.microsoft.com"' "$PROFILES_DIR/$selected.json")
  local transport=$(jq -r '.transport // "tcp"' "$PROFILES_DIR/$selected.json")

  echo ""
  echo -e "${CYAN}Текущий SNI профиля '$selected':${NC} ${GREEN}$current_sni${NC}"
  echo -e "${CYAN}Транспорт:${NC} ${YELLOW}$transport${NC}\n"

  # gRPC требует HTTP/2, российские сайты не поддерживают
  if [[ "$transport" == "grpc" ]]; then
    echo -e "${RED}╔═══════════════════════════════════════════════════════════╗${NC}"
    echo -e "${RED}║     ⚠ gRPC ТРЕБУЕТ ЗАРУБЕЖНЫЕ SNI (HTTP/2)              ║${NC}"
    echo -e "${RED}╚═══════════════════════════════════════════════════════════╝${NC}"
    echo ""
    echo -e "${YELLOW}gRPC работает только с сайтами поддерживающими HTTP/2.${NC}"
    echo -e "${YELLOW}Российские сайты (Ozon, WB, Sber и др.) НЕ поддерживают HTTP/2.${NC}"
    echo ""
    echo -e "${GREEN}Рекомендуемые SNI для gRPC:${NC}"
    echo -e "  ${CYAN}1)${NC} www.google.com ${BLUE}(рекомендуется)${NC}"
    echo -e "  ${CYAN}2)${NC} www.cloudflare.com"
    echo -e "  ${CYAN}3)${NC} www.microsoft.com"
    echo -e "  ${CYAN}4)${NC} github.com"
    echo -e "  ${CYAN}0)${NC} Назад\n"
    echo -n -e "${YELLOW}Выберите SNI для gRPC: ${NC}"
    read grpc_choice

    case $grpc_choice in
      1) new_sni="www.google.com" ;;
      2) new_sni="www.cloudflare.com" ;;
      3) new_sni="www.microsoft.com" ;;
      4) new_sni="github.com" ;;
      0|*) return ;;
    esac

    if [[ "$new_sni" == "$current_sni" ]]; then
      echo -e "${YELLOW}⚠ Этот SNI уже используется${NC}"
      sleep 2
      return
    fi

    # Переходим к обновлению SNI (пропускаем общий список)
    local port=$(jq -r '.port' "$PROFILES_DIR/$selected.json")
    local profiles_on_port=($(get_profiles_on_port "$port"))

    if [[ ${#profiles_on_port[@]} -gt 1 ]]; then
      echo ""
      echo -e "${RED}⚠ На порту $port есть другие профили:${NC}"
      for p in "${profiles_on_port[@]}"; do
        echo -e "  ${CYAN}•${NC} $p"
      done
      echo -e "${YELLOW}Все они будут обновлены на SNI: ${MAGENTA}$new_sni${NC}"
    fi

    echo ""
    echo -n -e "${YELLOW}Применить SNI '$new_sni'? (y/N): ${NC}"
    read confirm
    if [[ "$confirm" =~ ^[yYдД]$ ]]; then
      # Update profile JSON
      if ! safe_jq_write --arg sni "$new_sni" '.sni = $sni' "$PROFILES_DIR/$selected.json"; then
        echo -e "${RED}✗ Ошибка обновления профиля${NC}"
        sleep 2
        return
      fi

      # Update all profiles on port if shared
      if [[ ${#profiles_on_port[@]} -gt 1 ]]; then
        update_all_profiles_on_port "$port" "sni" "$new_sni"
      fi

      # Update config
      if ! update_transport_settings_for_sni "$port" "$new_sni" "$CONFIG_FILE"; then
        echo -e "${RED}✗ Ошибка обновления config.json${NC}"
        sleep 2
        return
      fi
      systemctl restart xray

      echo ""
      echo -e "${GREEN}✓ SNI профиля '$selected' изменен на: ${YELLOW}$new_sni${NC}"
      echo ""
      echo -n -e "${YELLOW}Нажмите Enter для продолжения...${NC}"
      read
    fi
    return
  fi

  if [[ ! -f "$SNI_LIST" ]]; then
    echo -e "${RED}✗ Файл списка SNI не найден${NC}"
    echo ""
    echo -n -e "${YELLOW}Нажмите Enter для продолжения...${NC}"
    read
    return
  fi

  declare -A sni_desc
  sni_desc["www.ozon.ru"]="E-commerce, макс. устойчивость для мобильных"
  sni_desc["api.ozon.ru"]="Ozon API, хорошо в паре с основным"
  sni_desc["st.ozon.ru"]="Ozon CDN статика"
  sni_desc["ir.ozon.ru"]="Ozon CDN изображения"
  sni_desc["www.wildberries.ru"]="E-commerce, стабильно для Мегафон/Ростелеком"
  sni_desc["splitter.wb.ru"]="Wildberries CDN"
  sni_desc["www.sberbank.ru"]="Банк, оптимально для региональных сетей"
  sni_desc["www.tinkoff.ru"]="Банк, стабильный вариант"
  sni_desc["www.alfabank.ru"]="Банк, запасной вариант"
  sni_desc["www.nspk.ru"]="Нац. платёжная система, сложно блокировать"
  sni_desc["sbp.nspk.ru"]="СБП, идеально для МТС"
  sni_desc["stats.vk-portal.net"]="VK мониторинг, хорош для стационарных"
  sni_desc["queuev4.vk.com"]="VK CDN, часто работает на мобильных"
  sni_desc["www.kinopoisk.ru"]="Медиа, обычно стабильный"
  sni_desc["www.gosuslugi.ru"]="Госуслуги, для сложных регионов"
  sni_desc["www.mos.ru"]="Портал Москвы"
  sni_desc["speller.yandex.net"]="Яндекс CDN, универсальный вариант"
  sni_desc["api-maps.yandex.ru"]="Яндекс Карты API"
  sni_desc["mc.yandex.ru"]="Яндекс Метрика"
  sni_desc["suggest.yandex.ru"]="Яндекс подсказки"
  sni_desc["www.github.com"]="Только если российские не работают!"
  sni_desc["www.cloudflare.com"]="Для корпоративных каналов"
  sni_desc["www.microsoft.com"]="Часто фильтруется"
  sni_desc["www.bbc.com"]="Редко работает"

  echo -e "${YELLOW}ТОП-20 доменов для маскировки:${NC}\n"
  local idx=1
  local sni_array=()
  while IFS='|' read -r domain category priority || [[ -n "$domain" ]]; do
    # Skip comments and empty lines
    [[ "$domain" =~ ^#.*$ ]] && continue
    [[ "$domain" =~ ^[[:space:]]*$ ]] && continue
    [[ -z "$domain" ]] && continue

    sni_array[$idx]="$domain"
    local desc="${sni_desc[$domain]}"
    [[ -z "$desc" ]] && desc="Дополнительный вариант"
    if [[ "$domain" == "$current_sni" ]]; then
      printf "${CYAN}%2d)${NC} %-40s ${GREEN}[текущий]${NC}\n" $idx "$domain"
    else
      printf "${CYAN}%2d)${NC} %-40s ${BLUE}%s${NC}\n" $idx "$domain" "$desc"
    fi
    ((idx++))
    [[ $idx -gt 20 ]] && break
  done < "$SNI_LIST"

  echo ""
  echo -e "${MAGENTA}Полный актуальный список:${NC} ${GREEN}$SNI_LIST${NC}"
  echo -e "${YELLOW}Обновляйте минимум раз в месяц!${NC}\n"
  echo -e "${CYAN} 0)${NC} Назад\n"
  echo -n -e "${YELLOW}Выберите новый SNI: ${NC}"
  read sni_choice

  if [[ "$sni_choice" == "0" ]]; then
    return
  fi

  local new_sni="${sni_array[$sni_choice]}"
  if [[ -z "$new_sni" ]]; then
    echo -e "${RED}✗ Неверный выбор${NC}"
    sleep 2
    return
  fi

  if [[ "$new_sni" == "$current_sni" ]]; then
    echo -e "${YELLOW}⚠ Этот SNI уже используется${NC}"
    sleep 2
    return
  fi

  # Check for shared inbound
  local port=$(jq -r '.port' "$PROFILES_DIR/$selected.json")
  local profiles_on_port=($(get_profiles_on_port "$port"))
  local shared_inbound=false

  if [[ ${#profiles_on_port[@]} -gt 1 ]]; then
    shared_inbound=true

    echo ""
    echo -e "${RED}╔═══════════════════════════════════════════════════════════╗${NC}"
    echo -e "${RED}║         ⚠ ВНИМАНИЕ: ОБЩИЙ INBOUND НА ПОРТУ $port        ║${NC}"
    echo -e "${RED}╚═══════════════════════════════════════════════════════════╝${NC}"
    echo ""
    echo -e "${YELLOW}Следующие профили используют порт $port:${NC}"
    echo ""

    for p in "${profiles_on_port[@]}"; do
      local psni=$(jq -r '.sni' "$PROFILES_DIR/$p.json")
      echo -e "  ${CYAN}•${NC} ${YELLOW}$p${NC} (текущий SNI: $psni)"
    done

    echo ""
    echo -e "${MAGENTA}Смена SNI обновит ВСЕ эти профили!${NC}"
    echo -e "${YELLOW}Все профили на порту $port будут использовать SNI: ${MAGENTA}$new_sni${NC}"
    echo ""
    echo -e "${CYAN}Xray Reality: SNI привязан к порту, а не к профилю.${NC}"
    echo -e "${CYAN}Для разных SNI используйте разные порты.${NC}"
    echo ""
  fi

  echo ""
  echo -e "${RED}╔═══════════════════════════════════════════════════════════╗${NC}"
  echo -e "${RED}║            ⚠ КРИТИЧЕСКОЕ ПРЕДУПРЕЖДЕНИЕ ⚠               ║${NC}"
  echo -e "${RED}╚═══════════════════════════════════════════════════════════╝${NC}"
  echo ""
  echo -e "${YELLOW}Смена SNI обновит конфигурацию профиля '$selected'.${NC}"
  echo ""
  echo -e "${RED}Активные подключения этого профиля будут разорваны!${NC}"
  echo ""
  echo -e "${CYAN}После смены необходимо:${NC}"
  echo -e "  ${BLUE}1.${NC} Получить НОВУЮ ссылку для профиля '$selected'"
  echo -e "  ${BLUE}2.${NC} Обновить конфигурацию в клиентах"
  echo ""
  echo -e "${MAGENTA}Новый SNI: ${YELLOW}$new_sni${NC}"
  echo ""
  echo -n -e "${YELLOW}Продолжить? (y/N): ${NC}"
  read confirm

  if [[ ! "$confirm" =~ ^[yYдД]$ ]]; then
    echo -e "${CYAN}✓ Отменено${NC}"
    sleep 1
    return
  fi

  # Update selected profile
  if ! safe_jq_write --arg sni "$new_sni" '.sni = $sni' "$PROFILES_DIR/$selected.json"; then
    echo -e "${RED}✗ Ошибка обновления профиля${NC}"
    sleep 2
    return
  fi

  # If shared inbound, update ALL profiles on port
  if [[ "$shared_inbound" == "true" ]]; then
    echo -e "${CYAN}Обновление всех профилей на порту $port...${NC}"
    update_all_profiles_on_port "$port" "sni" "$new_sni"
  fi

  # Update config (transport-aware)
  if ! update_transport_settings_for_sni "$port" "$new_sni" "$CONFIG_FILE"; then
    echo -e "${RED}✗ Ошибка обновления config.json${NC}"
    sleep 2
    return
  fi

  systemctl restart xray

  echo ""
  echo -e "${GREEN}✓ SNI профиля '$selected' изменен на: ${YELLOW}$new_sni${NC}"
  echo ""
  echo -e "${MAGENTA}╔═══════════════════════════════════════════════════════════╗${NC}"
  echo -e "${MAGENTA}║     Теперь получите новую ссылку для этого профиля!     ║${NC}"
  echo -e "${MAGENTA}╚═══════════════════════════════════════════════════════════╝${NC}"
  echo ""
  echo -n -e "${YELLOW}Нажмите Enter для продолжения...${NC}"
  read
}

# Смена Fingerprint
change_fingerprint_menu() {
  show_ascii
  echo -e "${BLUE}═══════════════════════════════════════════════${NC}"
  echo -e "${BLUE}   ПОДМЕНА FINGERPRINT (TLS БРАУЗЕР)         ${NC}"
  echo -e "${BLUE}═══════════════════════════════════════════════${NC}\n"

  local profiles=($(ls -1 "$PROFILES_DIR" 2>/dev/null | sed 's/.json//'))
  if [[ ${#profiles[@]} -eq 0 ]]; then
    echo -e "${RED}✗ Нет созданных профилей${NC}"
    echo ""
    echo -n -e "${YELLOW}Нажмите Enter для продолжения...${NC}"
    read
    return
  fi

  echo -e "${YELLOW}Выберите профиль для смены fingerprint:${NC}\n"
  local i=1
  for profile in "${profiles[@]}"; do
    local fp=$(jq -r '.fingerprint // "chrome"' "$PROFILES_DIR/$profile.json" 2>/dev/null)
    local port=$(jq -r '.port' "$PROFILES_DIR/$profile.json" 2>/dev/null)
    echo -e "${CYAN} $i)${NC} $profile ${BLUE}[порт:$port]${NC} ${YELLOW}[fp:$fp]${NC}"
    ((i++))
  done
  echo -e "${CYAN} 0)${NC} Назад в главное меню\n"

  echo -n -e "${YELLOW}Выберите профиль: ${NC}"
  read choice

  if [[ "$choice" == "0" ]]; then
    return
  fi

  if [[ ! "$choice" =~ ^[0-9]+$ ]] || [[ $choice -lt 1 ]] || [[ $choice -gt ${#profiles[@]} ]]; then
    echo -e "${RED}✗ Неверный выбор${NC}"
    sleep 2
    return
  fi

  local selected="${profiles[$((choice-1))]}"
  local current_fp=$(jq -r '.fingerprint // "chrome"' "$PROFILES_DIR/$selected.json")

  echo ""
  echo -e "${CYAN}Текущий fingerprint профиля '$selected':${NC} ${GREEN}$current_fp${NC}\n"
  echo -e "${YELLOW}Доступные fingerprint (эмуляция браузера):${NC}\n"
  echo -e "${CYAN} 1)${NC} chrome    ${BLUE}(стандартный, широкая совместимость)${NC}"
  echo -e "${CYAN} 2)${NC} firefox   ${GREEN}(рекомендуется при блокировках РКН)${NC}"
  echo -e "${CYAN} 3)${NC} safari    ${BLUE}(для iOS/macOS клиентов)${NC}"
  echo -e "${CYAN} 4)${NC} edge      ${BLUE}(альтернатива chrome)${NC}"
  echo -e "${CYAN} 5)${NC} ios       ${BLUE}(для старых iOS устройств)${NC}"
  echo -e "${CYAN} 6)${NC} random    ${YELLOW}(случайный, экспериментально)${NC}"
  echo -e "${CYAN} 0)${NC} Назад\n"

  echo -n -e "${YELLOW}Выберите новый fingerprint: ${NC}"
  read fp_choice

  local new_fp=""
  case $fp_choice in
    1) new_fp="chrome" ;;
    2) new_fp="firefox" ;;
    3) new_fp="safari" ;;
    4) new_fp="edge" ;;
    5) new_fp="ios" ;;
    6) new_fp="random" ;;
    0) return ;;
    *) echo -e "${RED}✗ Неверный выбор${NC}"; sleep 2; return ;;
  esac

  if [[ "$new_fp" == "$current_fp" ]]; then
    echo -e "${YELLOW}⚠ Этот fingerprint уже используется${NC}"
    sleep 2
    return
  fi

  # Check for shared inbound
  local port=$(jq -r '.port' "$PROFILES_DIR/$selected.json")
  local profiles_on_port=($(get_profiles_on_port "$port"))
  local shared_inbound=false

  if [[ ${#profiles_on_port[@]} -gt 1 ]]; then
    shared_inbound=true

    echo ""
    echo -e "${RED}╔═══════════════════════════════════════════════════════════╗${NC}"
    echo -e "${RED}║         ⚠ ВНИМАНИЕ: ОБЩИЙ INBOUND НА ПОРТУ $port        ║${NC}"
    echo -e "${RED}╚═══════════════════════════════════════════════════════════╝${NC}"
    echo ""
    echo -e "${YELLOW}Следующие профили используют порт $port:${NC}"
    echo ""

    for p in "${profiles_on_port[@]}"; do
      local pfp=$(jq -r '.fingerprint' "$PROFILES_DIR/$p.json")
      echo -e "  ${CYAN}•${NC} ${YELLOW}$p${NC} (текущий fingerprint: $pfp)"
    done

    echo ""
    echo -e "${MAGENTA}Смена fingerprint обновит ВСЕ эти профили!${NC}"
    echo -e "${YELLOW}Все профили на порту $port будут использовать fingerprint: ${MAGENTA}$new_fp${NC}"
    echo ""
    echo -e "${CYAN}Xray Reality: fingerprint привязан к порту, а не к профилю.${NC}"
    echo ""
  fi

  echo ""
  echo -e "${RED}╔═══════════════════════════════════════════════════════════╗${NC}"
  echo -e "${RED}║            ⚠ КРИТИЧЕСКОЕ ПРЕДУПРЕЖДЕНИЕ ⚠               ║${NC}"
  echo -e "${RED}╚═══════════════════════════════════════════════════════════╝${NC}"
  echo ""
  echo -e "${YELLOW}Смена fingerprint изменит TLS имитацию браузера.${NC}"
  echo ""
  echo -e "${RED}Активные подключения профиля '$selected' будут разорваны!${NC}"
  echo ""
  echo -e "${CYAN}После смены необходимо:${NC}"
  echo -e "  ${BLUE}1.${NC} Получить НОВУЮ ссылку для профиля '$selected'"
  echo -e "  ${BLUE}2.${NC} Обновить конфигурацию в клиентах"
  echo ""
  echo -e "${MAGENTA}Новый fingerprint: ${YELLOW}$new_fp${NC}"
  echo ""
  echo -n -e "${YELLOW}Продолжить? (y/N): ${NC}"
  read confirm

  if [[ ! "$confirm" =~ ^[yYдД]$ ]]; then
    echo -e "${CYAN}✓ Отменено${NC}"
    sleep 1
    return
  fi

  # Update selected profile
  if ! safe_jq_write --arg fp "$new_fp" '.fingerprint = $fp' "$PROFILES_DIR/$selected.json"; then
    echo -e "${RED}✗ Ошибка обновления профиля${NC}"
    sleep 2
    return
  fi

  # If shared inbound, update ALL profiles on port
  if [[ "$shared_inbound" == "true" ]]; then
    echo -e "${CYAN}Обновление всех профилей на порту $port...${NC}"
    update_all_profiles_on_port "$port" "fingerprint" "$new_fp"
  fi

  # Update config
  if ! safe_jq_write --argjson port "$port" --arg fp "$new_fp" '
    (.inbounds[] | select(.port == $port) | .streamSettings.realitySettings.fingerprint) |= $fp
  ' "$CONFIG_FILE"; then
    echo -e "${RED}✗ Ошибка обновления config.json${NC}"
    sleep 2
    return
  fi

  systemctl restart xray

  echo ""
  echo -e "${GREEN}✓ Fingerprint профиля '$selected' изменен на: ${YELLOW}$new_fp${NC}"
  echo ""
  echo -e "${MAGENTA}╔═══════════════════════════════════════════════════════════╗${NC}"
  echo -e "${MAGENTA}║     Теперь получите новую ссылку для этого профиля!     ║${NC}"
  echo -e "${MAGENTA}╚═══════════════════════════════════════════════════════════╝${NC}"
  echo ""
  echo -n -e "${YELLOW}Нажмите Enter для продолжения...${NC}"
  read
}

# Смена порта профиля
change_port_menu() {
  show_ascii
  echo -e "${BLUE}═══════════════════════════════════════════════${NC}"
  echo -e "${BLUE}         ИЗМЕНЕНИЕ ПОРТА ПРОФИЛЯ              ${NC}"
  echo -e "${BLUE}═══════════════════════════════════════════════${NC}\n"
  local profiles=($(ls -1 "$PROFILES_DIR" 2>/dev/null | sed 's/.json//'))
  if [[ ${#profiles[@]} -eq 0 ]]; then
    echo -e "${RED}✗ Нет созданных профилей${NC}"
    echo ""
    echo -n -e "${YELLOW}Нажмите Enter для продолжения...${NC}"
    read
    return
  fi
  echo -e "${YELLOW}Выберите профиль для изменения порта:${NC}\n"
  local i=1
  for profile in "${profiles[@]}"; do
    local transport=$(jq -r '.transport' "$PROFILES_DIR/$profile.json" 2>/dev/null)
    local port=$(jq -r '.port' "$PROFILES_DIR/$profile.json" 2>/dev/null)
    echo -e "${CYAN} $i)${NC} $profile ${BLUE}[$transport:$port]${NC}"
    ((i++))
  done
  echo -e "${CYAN} 0)${NC} Назад в главное меню\n"
  echo -n -e "${YELLOW}Выберите профиль: ${NC}"
  read choice
  if [[ "$choice" == "0" ]]; then
    return
  fi
  if [[ ! "$choice" =~ ^[0-9]+$ ]] || [[ $choice -lt 1 ]] || [[ $choice -gt ${#profiles[@]} ]]; then
    echo -e "${RED}✗ Неверный выбор${NC}"
    sleep 2
    return
  fi
  local profile_name="${profiles[$((choice-1))]}"
  local profile_file="$PROFILES_DIR/$profile_name.json"
  local old_port=$(jq -r '.port' "$profile_file")
  echo ""
  echo -e "${CYAN}Текущий порт профиля '$profile_name':${NC} ${GREEN}$old_port${NC}\n"
  echo -e "${YELLOW}Популярные порты для обхода блокировок:${NC}\n"
  echo -e "  ${GREEN}1)${NC} 443   ${BLUE}- HTTPS (самый популярный, наименее подозрительный)${NC}"
  echo -e "  ${GREEN}2)${NC} 8443  ${BLUE}- HTTPS альтернативный (часто используется)${NC}"
  echo -e "  ${GREEN}3)${NC} 2053  ${BLUE}- альтернативный HTTPS, хорош для gRPC${NC}"
  echo -e "  ${GREEN}4)${NC} 2083  ${BLUE}- Cloudflare альтернативный SSL${NC}"
  echo -e "  ${GREEN}5)${NC} 2087  ${BLUE}- Cloudflare альтернативный SSL${NC}"
  echo -e "  ${GREEN}6)${NC} 2096  ${BLUE}- Cloudflare альтернативный SSL${NC}"
  echo -e "  ${GREEN}7)${NC} 8080  ${BLUE}- HTTP альтернативный прокси${NC}"
  echo -e "  ${GREEN}8)${NC} 9443  ${BLUE}- для XHTTP протокола${NC}"
  echo -e "  ${CYAN}9)${NC} Свой порт (введу вручную)\n"
  echo -n -e "${YELLOW}Выберите порт: ${NC}"
  read port_choice
  local new_port=""
  case $port_choice in
    1) new_port="443" ;;
    2) new_port="8443" ;;
    3) new_port="2053" ;;
    4) new_port="2083" ;;
    5) new_port="2087" ;;
    6) new_port="2096" ;;
    7) new_port="8080" ;;
    8) new_port="9443" ;;
    9)
      echo -n -e "${YELLOW}Введите номер порта (1-65535): ${NC}"
      read new_port
      ;;
    0) return ;;
    *) echo -e "${RED}✗ Неверный выбор${NC}"; sleep 2; return ;;
  esac
  if [[ ! "$new_port" =~ ^[0-9]+$ ]] || [[ $new_port -lt 1 ]] || [[ $new_port -gt 65535 ]]; then
    echo -e "${RED}✗ Неверный порт. Используйте число от 1 до 65535${NC}"
    sleep 2
    return
  fi
  if [[ "$new_port" == "$old_port" ]]; then
    echo -e "${YELLOW}⚠ Профиль уже использует этот порт${NC}"
    sleep 2
    return
  fi

  # Get profile transport and UUID
  local profile_transport=$(jq -r '.transport' "$profile_file")
  local profile_uuid=$(jq -r '.uuid' "$profile_file")

  # Check if target port is already in use
  local target_inbound_tag=$(jq -r --argjson port "$new_port" '.inbounds[] | select(.port == $port) | .tag' "$CONFIG_FILE" 2>/dev/null)
  local target_inbound_transport=""
  local target_inbound_sni=""
  local move_to_existing=false

  if [[ -n "$target_inbound_tag" ]]; then
    # Port is in use - check transport compatibility
    target_inbound_transport=$(jq -r --argjson port "$new_port" '.inbounds[] | select(.port == $port) | .streamSettings.network' "$CONFIG_FILE")
    target_inbound_sni=$(jq -r --argjson port "$new_port" '.inbounds[] | select(.port == $port) | .streamSettings.realitySettings.serverNames[0]' "$CONFIG_FILE")

    # Normalize transport for comparison (tcp-utls, tcp-xudp, tcp-mux use tcp network)
    local profile_network="$profile_transport"
    case "$profile_transport" in
      tcp|tcp-utls|tcp-xudp|tcp-mux) profile_network="tcp" ;;
    esac

    if [[ "$profile_network" != "$target_inbound_transport" ]]; then
      echo -e "${RED}╔═══════════════════════════════════════════════════════════╗${NC}"
      echo -e "${RED}║            ✗ НЕСОВМЕСТИМЫЙ ТРАНСПОРТ                     ║${NC}"
      echo -e "${RED}╚═══════════════════════════════════════════════════════════╝${NC}"
      echo ""
      echo -e "${YELLOW}Порт $new_port уже занят профилем с транспортом: ${MAGENTA}$target_inbound_transport${NC}"
      echo -e "${YELLOW}Ваш профиль использует транспорт: ${MAGENTA}$profile_transport${NC}"
      echo ""
      echo -e "${CYAN}Нельзя объединить разные транспорты на одном порту.${NC}"
      echo ""
      echo -n -e "${YELLOW}Нажмите Enter для продолжения...${NC}"
      read
      return
    fi

    move_to_existing=true
    echo -e "${YELLOW}╔═══════════════════════════════════════════════════════════╗${NC}"
    echo -e "${YELLOW}║           ПОРТ УЖЕ ИСПОЛЬЗУЕТСЯ                          ║${NC}"
    echo -e "${YELLOW}╚═══════════════════════════════════════════════════════════╝${NC}"
    echo ""
    echo -e "${CYAN}Порт $new_port уже занят профилем с транспортом: ${GREEN}$target_inbound_transport${NC}"
    echo -e "${CYAN}SNI на этом порту: ${GREEN}$target_inbound_sni${NC}"
    echo ""
    echo -e "${MAGENTA}Профиль '$profile_name' будет перемещен на этот порт.${NC}"
    echo -e "${MAGENTA}SNI профиля изменится на: ${YELLOW}$target_inbound_sni${NC}"
    echo ""
  fi

  echo ""
  echo -e "${RED}╔═══════════════════════════════════════════════════════════╗${NC}"
  echo -e "${RED}║            ⚠ КРИТИЧЕСКОЕ ПРЕДУПРЕЖДЕНИЕ ⚠               ║${NC}"
  echo -e "${RED}╚═══════════════════════════════════════════════════════════╝${NC}"
  echo ""
  echo -e "${YELLOW}Смена порта изменит настройки подключения.${NC}"
  echo ""
  echo -e "${RED}ВСЕ активные подключения профиля '$profile_name' будут разорваны!${NC}"
  echo ""
  echo -e "${CYAN}После смены необходимо:${NC}"
  echo -e "  ${BLUE}1.${NC} Получить НОВУЮ ссылку/QR-код для этого профиля"
  echo -e "  ${BLUE}2.${NC} Обновить конфигурацию в клиентах"
  echo -e "  ${BLUE}3.${NC} Убедиться, что порт открыт в firewall"
  echo ""
  echo -e "${MAGENTA}Порт изменится: ${YELLOW}$old_port → $new_port${NC}"
  echo ""
  echo -n -e "${YELLOW}Продолжить смену порта? (y/N): ${NC}"
  read confirm
  if [[ ! "$confirm" =~ ^[yYдД]$ ]]; then
    echo -e "${CYAN}✓ Отменено${NC}"
    sleep 1
    return
  fi

  if [[ "$move_to_existing" == "true" ]]; then
    # Move client to existing inbound on target port
    echo -e "${CYAN}  → Перемещение клиента на порт $new_port...${NC}"

    # Определяем flow по типу транспорта профиля
    local target_flow=""
    case "$profile_transport" in
      tcp|tcp-utls|tcp-xudp) target_flow="xtls-rprx-vision" ;;
      tcp-mux|grpc|xhttp) target_flow="" ;;
    esac

    # Шаг 1: Добавить клиента на новый порт
    if ! safe_jq_write --arg uuid "$profile_uuid" --argjson port "$new_port" --arg flow "$target_flow" '
      (.inbounds[] | select(.port == $port) | .settings.clients) += [{"id": $uuid, "flow": $flow}]
    ' "$CONFIG_FILE"; then
      echo -e "${RED}  ✗ Ошибка добавления клиента на порт $new_port — операция отменена${NC}"
      echo -n -e "${YELLOW}Нажмите Enter...${NC}"; read
      return
    fi

    # Шаг 2: Удалить клиента со старого порта
    if ! safe_jq_write --arg uuid "$profile_uuid" --argjson port "$old_port" '
      (.inbounds[] | select(.port == $port) | .settings.clients) |= map(select(.id != $uuid))
    ' "$CONFIG_FILE"; then
      echo -e "${RED}  ✗ Ошибка удаления клиента с порта $old_port${NC}"
      echo -e "${YELLOW}  → Откат: удаление клиента с нового порта $new_port...${NC}"
      safe_jq_write --arg uuid "$profile_uuid" --argjson port "$new_port" '
        (.inbounds[] | select(.port == $port) | .settings.clients) |= map(select(.id != $uuid))
      ' "$CONFIG_FILE"
      echo -n -e "${YELLOW}Нажмите Enter...${NC}"; read
      return
    fi

    # Шаг 3: Если старый inbound пуст — удалить его
    local old_clients_count=$(jq -r --argjson port "$old_port" '.inbounds[] | select(.port == $port) | .settings.clients | length' "$CONFIG_FILE")
    if [[ "$old_clients_count" == "0" ]]; then
      echo -e "${CYAN}  → Удаление пустого inbound на порту $old_port...${NC}"
      safe_jq_write --argjson port "$old_port" 'del(.inbounds[] | select(.port == $port))' "$CONFIG_FILE"
      close_firewall_port "$old_port"
    fi

    # Шаг 4: Обновить файл профиля (port + sni + fingerprint целевого inbound)
    local target_fp=$(jq -r --argjson port "$new_port" \
      '.inbounds[] | select(.port == $port) | .streamSettings.realitySettings.fingerprint' \
      "$CONFIG_FILE" 2>/dev/null)
    [[ -z "$target_fp" ]] && target_fp="chrome"
    safe_jq_write --argjson port "$new_port" --arg sni "$target_inbound_sni" --arg fp "$target_fp" \
      '.port = $port | .sni = $sni | .fingerprint = $fp' "$profile_file"

  else
    # Move entire inbound to new port (original logic)
    if ! safe_jq_write --arg old_tag "inbound-$old_port" --argjson new_port "$new_port" '
      (.inbounds[] | select(.tag == $old_tag) | .port) |= $new_port |
      (.inbounds[] | select(.tag == $old_tag) | .tag) |= ("inbound-" + ($new_port | tostring))
    ' "$CONFIG_FILE"; then
      echo -e "${RED}  ✗ Ошибка смены порта в конфиге — операция отменена${NC}"
      echo -n -e "${YELLOW}Нажмите Enter...${NC}"; read
      return
    fi

    # Обновить ВСЕ профили на старом порту (inbound перенесён целиком)
    local moved_profiles=($(get_profiles_on_port "$old_port"))
    for mp in "${moved_profiles[@]}"; do
      safe_jq_write --argjson port "$new_port" '.port = $port' "$PROFILES_DIR/$mp.json"
    done
    # На случай если выбранный профиль не попал в список (уже обновлён)
    safe_jq_write --argjson port "$new_port" '.port = $port' "$profile_file"

    # Update firewall
    open_firewall_port "$new_port"
    close_firewall_port "$old_port"
  fi

  systemctl restart xray
  echo ""
  echo -e "${GREEN}✓ Порт профиля '$profile_name' изменен: ${YELLOW}$old_port → $new_port${NC}"
  echo ""
  echo -e "${MAGENTA}╔═══════════════════════════════════════════════════════════╗${NC}"
  echo -e "${MAGENTA}║        Теперь ОБЯЗАТЕЛЬНО получите новую ссылку!        ║${NC}"
  echo -e "${MAGENTA}╚═══════════════════════════════════════════════════════════╝${NC}"
  echo ""
  echo -n -e "${YELLOW}Нажмите Enter для продолжения...${NC}"
  read
}

# ═══════════════════════════════════════════════════════════
# ADGUARD HOME
# ═══════════════════════════════════════════════════════════

# Подменю AdGuard Home
adguard_home_menu() {
  while true; do
    show_ascii
    echo -e "${BLUE}╔════════════════════════════════════════╗${NC}"
    echo -e "${BLUE}║      ADGUARD HOME — БЛОКИРОВКА РЕКЛАМЫ ║${NC}"
    echo -e "${BLUE}╚════════════════════════════════════════╝${NC}"
    echo ""

    # Быстрый статус
    if [[ -f /opt/AdGuardHome/AdGuardHome ]]; then
      local agh_status=$(systemctl is-active AdGuardHome 2>/dev/null || echo "inactive")
      if [[ "$agh_status" == "active" ]]; then
        echo -e "  ${GREEN}● AdGuard Home работает${NC}"
      else
        echo -e "  ${RED}● AdGuard Home остановлен${NC}"
      fi
    else
      echo -e "  ${YELLOW}○ AdGuard Home не установлен${NC}"
    fi
    echo ""

    echo -e "${CYAN} 1)${NC} Установить AdGuard Home"
    echo -e "${CYAN} 2)${NC} Удалить AdGuard Home"
    echo -e "${CYAN} 3)${NC} Показать статус"
    echo -e "${RED} 0)${NC} Назад"
    echo ""
    echo -n -e "${YELLOW}Выберите действие: ${NC}"
    read agh_choice
    case $agh_choice in
      1) install_adguard_home ;;
      2) uninstall_adguard_home ;;
      3) adguard_status ;;
      0) return ;;
      *) echo -e "${RED}Неверный выбор${NC}"; sleep 1 ;;
    esac
  done
}

# Установка AdGuard Home
install_adguard_home() {
  show_ascii
  echo -e "${BLUE}═══════════════════════════════════════════════${NC}"
  echo -e "${BLUE}       УСТАНОВКА ADGUARD HOME                 ${NC}"
  echo -e "${BLUE}═══════════════════════════════════════════════${NC}"
  echo ""

  # Шаг 1: Проверка — уже установлен?
  if [[ -f /opt/AdGuardHome/AdGuardHome ]]; then
    echo -e "${YELLOW}⚠ AdGuard Home уже установлен${NC}"
    echo ""
    local agh_ver=$(/opt/AdGuardHome/AdGuardHome --version 2>/dev/null | head -1)
    [[ -n "$agh_ver" ]] && echo -e "${CYAN}Версия: ${GREEN}$agh_ver${NC}"
    echo ""
    echo -n -e "${YELLOW}Нажмите Enter для продолжения...${NC}"
    read
    return
  fi

  # Учётные данные администратора
  echo -e "${CYAN}Создайте учётную запись администратора Web UI:${NC}"
  echo ""
  echo -n -e "${YELLOW}Логин: ${NC}"
  read agh_user
  if [[ -z "$agh_user" ]]; then
    echo -e "${RED}✗ Логин не может быть пустым${NC}"
    sleep 2
    return
  fi
  echo -n -e "${YELLOW}Пароль: ${NC}"
  read -s agh_pass
  echo ""
  if [[ -z "$agh_pass" ]]; then
    echo -e "${RED}✗ Пароль не может быть пустым${NC}"
    sleep 2
    return
  fi
  echo -n -e "${YELLOW}Повторите пароль: ${NC}"
  read -s agh_pass2
  echo ""
  if [[ "$agh_pass" != "$agh_pass2" ]]; then
    echo -e "${RED}✗ Пароли не совпадают${NC}"
    sleep 2
    return
  fi
  echo ""

  echo -e "${CYAN}Шаг 1/7: Проверка зависимостей...${NC}"

  # Установка htpasswd для генерации bcrypt хэша
  if ! command -v htpasswd &>/dev/null; then
    echo -e "${CYAN}  → Установка apache2-utils (для bcrypt)...${NC}"
    apt-get install -y apache2-utils >/dev/null 2>&1
  fi

  # Генерация bcrypt хэша пароля
  local agh_pass_hash
  if command -v htpasswd &>/dev/null; then
    agh_pass_hash=$(htpasswd -nbBC 10 "" "$agh_pass" 2>/dev/null | cut -d: -f2)
  fi

  if [[ -z "$agh_pass_hash" ]]; then
    echo -e "${RED}✗ Не удалось сгенерировать хэш пароля${NC}"
    echo -e "${YELLOW}Установите apache2-utils: apt install apache2-utils${NC}"
    sleep 2
    return
  fi
  echo -e "${GREEN}  ✓ Хэш пароля сгенерирован${NC}"

  # Шаг 2: Проверка порта 53
  echo -e "${CYAN}Шаг 2/7: Проверка порта 53...${NC}"
  local port53_busy=$(ss -tuln 2>/dev/null | grep -E ':53\s' | head -1)
  if [[ -n "$port53_busy" ]]; then
    echo -e "${YELLOW}  ⚠ Порт 53 занят — отключаю systemd-resolved stub listener...${NC}"
    mkdir -p /etc/systemd/resolved.conf.d
    cat > /etc/systemd/resolved.conf.d/adguardhome.conf << 'RESOLVEDEOF'
[Resolve]
DNS=127.0.0.1
DNSStubListener=no
RESOLVEDEOF
    # Обновляем symlink resolv.conf
    if [[ -L /etc/resolv.conf ]]; then
      ln -sf /run/systemd/resolve/resolv.conf /etc/resolv.conf 2>/dev/null || true
    fi
    systemctl restart systemd-resolved 2>/dev/null || true
    sleep 2
    echo -e "${GREEN}  ✓ systemd-resolved stub listener отключен${NC}"
  else
    echo -e "${GREEN}  ✓ Порт 53 свободен${NC}"
  fi

  # Шаг 3: Скачивание установщика
  echo -e "${CYAN}Шаг 3/7: Скачивание AdGuard Home...${NC}"
  if ! curl -fsSL https://raw.githubusercontent.com/AdguardTeam/AdGuardHome/master/scripts/install.sh -o /tmp/agh_install.sh; then
    echo -e "${RED}✗ Ошибка скачивания установщика${NC}"
    echo -n -e "${YELLOW}Нажмите Enter для продолжения...${NC}"
    read
    return
  fi
  echo -e "${GREEN}  ✓ Установщик скачан${NC}"

  # Шаг 4: Запуск установщика
  echo -e "${CYAN}Шаг 4/7: Установка...${NC}"
  if ! sh /tmp/agh_install.sh -v; then
    echo -e "${RED}✗ Ошибка установки AdGuard Home${NC}"
    rm -f /tmp/agh_install.sh
    echo -n -e "${YELLOW}Нажмите Enter для продолжения...${NC}"
    read
    return
  fi
  rm -f /tmp/agh_install.sh
  echo -e "${GREEN}  ✓ AdGuard Home установлен${NC}"

  # Шаг 5: Конфигурация
  echo -e "${CYAN}Шаг 5/7: Запись конфигурации...${NC}"
  systemctl stop AdGuardHome 2>/dev/null || true

  cat > /opt/AdGuardHome/AdGuardHome.yaml << 'AGHEOF'
http:
  pprof:
    port: 6060
    enabled: false
  address: 127.0.0.1:3000
  session_ttl: 720h
users: []
auth_attempts: 5
block_auth_min: 15
http_proxy: ""
language: ru
theme: auto
dns:
  bind_hosts:
    - 0.0.0.0
  port: 53
  anonymize_client_ip: false
  ratelimit: 0
  ratelimit_subnet_len_ipv4: 24
  ratelimit_subnet_len_ipv6: 56
  ratelimit_whitelist: []
  refuse_any: true
  upstream_dns:
    - 1.1.1.1
    - 8.8.8.8
  upstream_dns_file: ""
  bootstrap_dns:
    - 9.9.9.10
    - 149.112.112.10
    - 2620:fe::10
    - 2620:fe::fe:10
  fallback_dns: []
  upstream_mode: load_balance
  fastest_timeout: 1s
  allowed_clients: []
  disallowed_clients: []
  blocked_hosts:
    - version.bind
    - id.server
    - hostname.bind
  trusted_proxies:
    - 127.0.0.0/8
    - ::1/128
  cache_size: 4194304
  cache_ttl_min: 0
  cache_ttl_max: 0
  cache_optimistic: true
  bogus_nxdomain: []
  aaaa_disabled: false
  enable_dnssec: false
  edns_client_subnet:
    custom_ip: ""
    enabled: false
    use_custom: false
  max_goroutines: 300
  handle_ddr: true
  ipset: []
  ipset_file: ""
  bootstrap_prefer_ipv6: false
  upstream_timeout: 10s
  private_networks: []
  use_private_ptr_resolvers: true
  local_ptr_upstreams: []
  use_dns64: false
  dns64_prefixes: []
  serve_http3: false
  use_http3_upstreams: false
  serve_plain_dns: true
  hostsfile_enabled: true
tls:
  enabled: false
  server_name: ""
  force_https: false
  port_https: 443
  port_dns_over_tls: 853
  port_dns_over_quic: 784
  port_dnscrypt: 0
  dnscrypt_config_file: ""
  allow_unencrypted_doh: false
  certificate_chain: ""
  private_key: ""
  certificate_path: ""
  private_key_path: ""
  strict_sni_check: false
querylog:
  dir_path: ""
  ignored: []
  interval: 24h
  size_memory: 1000
  enabled: true
  file_enabled: true
statistics:
  dir_path: ""
  ignored: []
  interval: 24h
  enabled: true
filters:
  - enabled: true
    url: https://adguardteam.github.io/HostlistsRegistry/assets/filter_1.txt
    name: AdGuard DNS filter
    id: 1
  - enabled: true
    url: https://adguardteam.github.io/HostlistsRegistry/assets/filter_2.txt
    name: AdAway Default Blocklist
    id: 2
whitelist_filters: []
user_rules: []
dhcp:
  enabled: false
  interface_name: ""
  local_domain_name: lan
  dhcpv4:
    gateway_ip: ""
    subnet_mask: ""
    range_start: ""
    range_end: ""
    lease_duration: 86400
    icmp_timeout_msec: 1000
    options: []
  dhcpv6:
    range_start: ""
    lease_duration: 86400
    ra_slaac_only: false
    ra_allow_slaac: false
filtering:
  blocking_ipv4: ""
  blocking_ipv6: ""
  blocked_services:
    schedule:
      time_zone: Local
    ids: []
  protection_disabled_until: null
  safe_search:
    enabled: false
    bing: true
    duckduckgo: true
    ecosia: true
    google: true
    pixabay: true
    yandex: true
    youtube: true
  blocking_mode: default
  parental_block_host: family-block.dns.adguard.com
  safebrowsing_block_host: standard-block.dns.adguard.com
  rewrites: []
  safebrowsing_cache_size: 1048576
  safesearch_cache_size: 1048576
  parental_cache_size: 1048576
  cache_time: 30
  filters_update_interval: 24
  blocked_response_ttl: 10
  filtering_enabled: true
  parental_enabled: false
  safebrowsing_enabled: false
  protection_enabled: true
clients:
  runtime_sources:
    whois: true
    arp: true
    rdns: true
    dhcp: true
    hosts: true
  persistent: []
log:
  enabled: true
  file: ""
  max_backups: 0
  max_size: 100
  max_age: 3
  compress: false
  local_time: false
  verbose: false
os:
  group: ""
  user: ""
  rlimit_nofile: 0
schema_version: 29
AGHEOF

  # Подстановка учётных данных (bcrypt хэш содержит $, sed ненадёжен)
  python3 -c "
import sys
data = open('/opt/AdGuardHome/AdGuardHome.yaml').read()
data = data.replace(
    'users: []',
    'users:\n  - name: ' + sys.argv[1] + '\n    password: ' + sys.argv[2])
open('/opt/AdGuardHome/AdGuardHome.yaml', 'w').write(data)
" "$agh_user" "$agh_pass_hash"

  chown root:root /opt/AdGuardHome/AdGuardHome.yaml
  chmod 600 /opt/AdGuardHome/AdGuardHome.yaml
  echo -e "${GREEN}  ✓ Конфигурация записана${NC}"

  # Шаг 6: Интеграция с Xray DNS
  echo -e "${CYAN}Шаг 6/7: Интеграция с Xray...${NC}"
  if [[ -f "$CONFIG_FILE" ]]; then
    local temp_config=$(mktemp)
    jq '.dns = {
      "servers": ["127.0.0.1"],
      "queryStrategy": "UseIPv4",
      "disableCache": false
    }' "$CONFIG_FILE" > "$temp_config"

    if [[ $? -eq 0 ]] && [[ -s "$temp_config" ]]; then
      mv "$temp_config" "$CONFIG_FILE"
      chown root:root "$CONFIG_FILE"
      chmod 644 "$CONFIG_FILE"
      echo -e "${GREEN}  ✓ Xray DNS → 127.0.0.1 (AdGuard Home)${NC}"
    else
      rm -f "$temp_config"
      echo -e "${RED}  ✗ Ошибка обновления Xray DNS${NC}"
    fi
  fi

  # Шаг 7: Запуск
  echo -e "${CYAN}Шаг 7/7: Запуск служб...${NC}"
  systemctl start AdGuardHome
  systemctl enable AdGuardHome 2>/dev/null || true
  systemctl restart xray

  # Открываем DNS порт (UDP + TCP) — только для Xray (127.0.0.1)
  open_firewall_port 53
  open_firewall_port 53 udp
  # Порт 3000 НЕ открываем — Web UI доступен только через SSH-туннель

  echo ""
  echo -e "${GREEN}╔═══════════════════════════════════════════════════════════╗${NC}"
  echo -e "${GREEN}║         ✓ ADGUARD HOME УСПЕШНО УСТАНОВЛЕН!              ║${NC}"
  echo -e "${GREEN}╚═══════════════════════════════════════════════════════════╝${NC}"
  echo ""
  echo -e "${CYAN}Логин:${NC} ${GREEN}$agh_user${NC}"
  echo -e "${CYAN}Фильтры:${NC} AdGuard DNS + AdAway (включены)"
  echo -e "${CYAN}Xray DNS:${NC} 127.0.0.1 (AdGuard Home)"
  echo ""
  echo -e "${MAGENTA}╔═══════════════════════════════════════════════════════════╗${NC}"
  echo -e "${MAGENTA}║  Web UI доступен ТОЛЬКО через SSH-туннель (безопасно):  ║${NC}"
  echo -e "${MAGENTA}╚═══════════════════════════════════════════════════════════╝${NC}"
  echo ""
  echo -e "${YELLOW}  На вашем ПК выполните:${NC}"
  echo ""
  echo -e "${GREEN}  ssh -L 3000:127.0.0.1:3000 root@${SERVER_IP}${NC}"
  echo ""
  echo -e "${CYAN}  Затем откройте:${NC} ${YELLOW}http://localhost:3000${NC}"
  echo ""
  echo -n -e "${YELLOW}Нажмите Enter для продолжения...${NC}"
  read
}

# Удаление AdGuard Home
uninstall_adguard_home() {
  show_ascii
  echo -e "${BLUE}═══════════════════════════════════════════════${NC}"
  echo -e "${BLUE}        УДАЛЕНИЕ ADGUARD HOME                 ${NC}"
  echo -e "${BLUE}═══════════════════════════════════════════════${NC}"
  echo ""

  # Шаг 1: Проверка — установлен?
  if [[ ! -f /opt/AdGuardHome/AdGuardHome ]]; then
    echo -e "${YELLOW}⚠ AdGuard Home не установлен${NC}"
    echo ""
    echo -n -e "${YELLOW}Нажмите Enter для продолжения...${NC}"
    read
    return
  fi

  # Шаг 2: Подтверждение
  echo -e "${RED}╔═══════════════════════════════════════════════════════════╗${NC}"
  echo -e "${RED}║            ⚠ УДАЛЕНИЕ ADGUARD HOME ⚠                   ║${NC}"
  echo -e "${RED}╚═══════════════════════════════════════════════════════════╝${NC}"
  echo ""
  echo -e "${YELLOW}Будут удалены:${NC}"
  echo -e "  ${CYAN}•${NC} AdGuard Home и все его настройки"
  echo -e "  ${CYAN}•${NC} Фильтры и статистика"
  echo -e "  ${CYAN}•${NC} Интеграция с Xray DNS"
  echo ""
  echo -e "${CYAN}Xray DNS будет восстановлен на AdGuard DoH (dns.adguard-dns.com).${NC}"
  echo ""
  echo -n -e "${RED}Вы уверены? (y/N): ${NC}"
  read confirm
  if [[ ! "$confirm" =~ ^[yYдД]$ ]]; then
    echo -e "${CYAN}✓ Отменено${NC}"
    sleep 1
    return
  fi

  echo ""

  # Шаг 3: Остановка службы
  echo -e "${CYAN}Шаг 1/6: Остановка AdGuard Home...${NC}"
  systemctl stop AdGuardHome 2>/dev/null || true
  systemctl disable AdGuardHome 2>/dev/null || true
  echo -e "${GREEN}  ✓ Служба остановлена${NC}"

  # Шаг 4: Удаление
  echo -e "${CYAN}Шаг 2/6: Удаление файлов...${NC}"
  /opt/AdGuardHome/AdGuardHome -s uninstall 2>/dev/null || true
  rm -rf /opt/AdGuardHome/
  echo -e "${GREEN}  ✓ AdGuard Home удалён${NC}"

  # Шаг 5: Восстановление Xray DNS
  echo -e "${CYAN}Шаг 3/6: Восстановление Xray DNS...${NC}"
  if [[ -f "$CONFIG_FILE" ]]; then
    local temp_config=$(mktemp)
    jq '.dns = {
      "servers": [
        {
          "address": "https://dns.adguard-dns.com/dns-query",
          "domains": ["geosite:category-ads-all"],
          "expectIPs": ["127.0.0.1"]
        },
        "https://dns.adguard-dns.com/dns-query"
      ],
      "queryStrategy": "UseIPv4",
      "disableCache": false
    }' "$CONFIG_FILE" > "$temp_config"

    if [[ $? -eq 0 ]] && [[ -s "$temp_config" ]]; then
      mv "$temp_config" "$CONFIG_FILE"
      chown root:root "$CONFIG_FILE"
      chmod 644 "$CONFIG_FILE"
      echo -e "${GREEN}  ✓ Xray DNS → AdGuard DoH${NC}"
    else
      rm -f "$temp_config"
      echo -e "${RED}  ✗ Ошибка восстановления Xray DNS${NC}"
    fi
  fi

  # Шаг 6: Восстановление systemd-resolved
  echo -e "${CYAN}Шаг 4/6: Восстановление systemd-resolved...${NC}"
  if [[ -f /etc/systemd/resolved.conf.d/adguardhome.conf ]]; then
    rm -f /etc/systemd/resolved.conf.d/adguardhome.conf
    # Восстанавливаем resolv.conf на стандартный stub
    if [[ -L /etc/resolv.conf ]] || [[ -f /etc/resolv.conf ]]; then
      ln -sf /run/systemd/resolve/stub-resolv.conf /etc/resolv.conf 2>/dev/null || true
    fi
    systemctl restart systemd-resolved 2>/dev/null || true
    echo -e "${GREEN}  ✓ systemd-resolved восстановлен${NC}"
  else
    echo -e "${GREEN}  ✓ systemd-resolved не был изменён${NC}"
  fi

  # Закрытие портов
  echo -e "${CYAN}Шаг 5/6: Закрытие портов...${NC}"
  if command -v ufw &>/dev/null; then
    ufw delete allow 3000/tcp >/dev/null 2>&1  # На случай если открывали вручную
    ufw reload >/dev/null 2>&1
  fi
  echo -e "${GREEN}  ✓ Порты проверены${NC}"

  # Перезапуск Xray
  echo -e "${CYAN}Шаг 6/6: Перезапуск Xray...${NC}"
  systemctl restart xray
  echo -e "${GREEN}  ✓ Xray перезапущен${NC}"

  echo ""
  echo -e "${GREEN}╔═══════════════════════════════════════════════════════════╗${NC}"
  echo -e "${GREEN}║         ✓ ADGUARD HOME УСПЕШНО УДАЛЁН                   ║${NC}"
  echo -e "${GREEN}╚═══════════════════════════════════════════════════════════╝${NC}"
  echo ""
  echo -e "${CYAN}Xray DNS восстановлен на AdGuard DoH (dns.adguard-dns.com).${NC}"
  echo ""
  echo -n -e "${YELLOW}Нажмите Enter для продолжения...${NC}"
  read
}

# Статус AdGuard Home
adguard_status() {
  show_ascii
  echo -e "${BLUE}═══════════════════════════════════════════════${NC}"
  echo -e "${BLUE}         СТАТУС ADGUARD HOME                  ${NC}"
  echo -e "${BLUE}═══════════════════════════════════════════════${NC}"
  echo ""

  # Бинарник
  if [[ -f /opt/AdGuardHome/AdGuardHome ]]; then
    echo -e "${GREEN}  ✓ Установлен${NC}"

    # Версия
    local agh_ver=$(/opt/AdGuardHome/AdGuardHome --version 2>/dev/null | head -1)
    if [[ -n "$agh_ver" ]]; then
      echo -e "${CYAN}  Версия:${NC} $agh_ver"
    fi
  else
    echo -e "${RED}  ✗ Не установлен${NC}"
    echo ""
    echo -e "${YELLOW}Установите через меню: 1) Установить AdGuard Home${NC}"
    echo ""
    echo -n -e "${YELLOW}Нажмите Enter для продолжения...${NC}"
    read
    return
  fi

  # Статус службы
  local svc_status=$(systemctl is-active AdGuardHome 2>/dev/null || echo "inactive")
  if [[ "$svc_status" == "active" ]]; then
    echo -e "${GREEN}  ● Служба: работает${NC}"
  else
    echo -e "${RED}  ● Служба: $svc_status${NC}"
  fi

  # DNS порт 53
  echo ""
  echo -e "${CYAN}  Порты:${NC}"
  local dns_listen=$(ss -tuln 2>/dev/null | grep -E ':53\s' | head -3)
  if [[ -n "$dns_listen" ]]; then
    echo -e "${GREEN}    ✓ DNS (порт 53) — слушает${NC}"
  else
    echo -e "${RED}    ✗ DNS (порт 53) — не слушает${NC}"
  fi

  # Web UI порт 3000
  local web_listen=$(ss -tuln 2>/dev/null | grep -E ':3000\s' | head -1)
  if [[ -n "$web_listen" ]]; then
    echo -e "${GREEN}    ✓ Web UI (порт 3000) — слушает${NC}"
  else
    echo -e "${RED}    ✗ Web UI (порт 3000) — не слушает${NC}"
  fi

  # Интеграция с Xray
  echo ""
  echo -e "${CYAN}  Интеграция с Xray:${NC}"
  if [[ -f "$CONFIG_FILE" ]]; then
    local xray_dns_server=$(jq -r '.dns.servers[0] // "не задан"' "$CONFIG_FILE" 2>/dev/null)
    if [[ "$xray_dns_server" == "127.0.0.1" ]]; then
      echo -e "${GREEN}    ✓ Xray DNS → 127.0.0.1 (AdGuard Home)${NC}"
    else
      echo -e "${YELLOW}    ⚠ Xray DNS → $xray_dns_server (не через AdGuard Home)${NC}"
    fi
  fi

  # Web UI доступ
  echo ""
  echo -e "${CYAN}  Web UI (через SSH-туннель):${NC}"
  echo -e "${GREEN}    ssh -L 3000:127.0.0.1:3000 root@${SERVER_IP}${NC}"
  echo -e "${CYAN}    Затем:${NC} ${YELLOW}http://localhost:3000${NC}"

  echo ""
  echo -n -e "${YELLOW}Нажмите Enter для продолжения...${NC}"
  read
}

# Запуск главного меню
main_menu
